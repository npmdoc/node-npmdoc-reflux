<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/reflux/refluxjs#readme">reflux (v6.4.1)</a>
</h1>
<h4>A simple library for uni-directional dataflow application architecture inspired by ReactJS Flux</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux">module reflux</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.</span>serverMode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component">
            function <span class="apidocSignatureSpan">reflux.</span>Component
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.extend">
            function <span class="apidocSignatureSpan">reflux.</span>Component.extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.hasListener">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinConcat">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinLeading">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinStrict">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenTo">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenToMany">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.validateListening">
            function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.deferWith">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.deferWith
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.listen">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.listen
            <span class="apidocSignatureSpan">(callback, bindContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.preEmit">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.preEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.shouldEmit">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.shouldEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.trigger">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.trigger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.triggerAsync">
            function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.triggerAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.extend">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent.extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store">
            function <span class="apidocSignatureSpan">reflux.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.prototype.setState">
            function <span class="apidocSignatureSpan">reflux.</span>Store.prototype.setState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addAction">
            function <span class="apidocSignatureSpan">reflux.</span>__keep.addAction
            <span class="apidocSignatureSpan">(act)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addStore">
            function <span class="apidocSignatureSpan">reflux.</span>__keep.addStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.reset">
            function <span class="apidocSignatureSpan">reflux.</span>__keep.reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.useKeep">
            function <span class="apidocSignatureSpan">reflux.</span>__keep.useKeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.all">
            function <span class="apidocSignatureSpan">reflux.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connect">
            function <span class="apidocSignatureSpan">reflux.</span>connect
            <span class="apidocSignatureSpan">(listenable, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connectFilter">
            function <span class="apidocSignatureSpan">reflux.</span>connectFilter
            <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createAction">
            function <span class="apidocSignatureSpan">reflux.</span>createAction
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createActions">
            function <span class="apidocSignatureSpan">reflux.</span>createActions
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createStore">
            function <span class="apidocSignatureSpan">reflux.</span>createStore
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.defineReact">
            function <span class="apidocSignatureSpan">reflux.</span>defineReact
            <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.getGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.initStore">
            function <span class="apidocSignatureSpan">reflux.</span>initStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.initializeGlobalStore">
            function <span class="apidocSignatureSpan">reflux.</span>initializeGlobalStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinConcat">
            function <span class="apidocSignatureSpan">reflux.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinLeading">
            function <span class="apidocSignatureSpan">reflux.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinStrict">
            function <span class="apidocSignatureSpan">reflux.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.karma_conf">
            function <span class="apidocSignatureSpan">reflux.</span>karma_conf
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenTo">
            function <span class="apidocSignatureSpan">reflux.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenToMany">
            function <span class="apidocSignatureSpan">reflux.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.nextTick">
            function <span class="apidocSignatureSpan">reflux.</span>nextTick
            <span class="apidocSignatureSpan">(nextTick)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setEventEmitter">
            function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.use">
            function <span class="apidocSignatureSpan">reflux.</span>use
            <span class="apidocSignatureSpan">(pluginCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.on">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.once">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.callbackName">
            function <span class="apidocSignatureSpan">reflux.</span>utils.callbackName
            <span class="apidocSignatureSpan">(string, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.capitalize">
            function <span class="apidocSignatureSpan">reflux.</span>utils.capitalize
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.extend">
            function <span class="apidocSignatureSpan">reflux.</span>utils.extend
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.inherits">
            function <span class="apidocSignatureSpan">reflux.</span>utils.inherits
            <span class="apidocSignatureSpan">(subClass, superClass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isArguments">
            function <span class="apidocSignatureSpan">reflux.</span>utils.isArguments
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isFunction">
            function <span class="apidocSignatureSpan">reflux.</span>utils.isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isObject">
            function <span class="apidocSignatureSpan">reflux.</span>utils.isObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.nextTick">
            function <span class="apidocSignatureSpan">reflux.</span>utils.nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.object">
            function <span class="apidocSignatureSpan">reflux.</span>utils.object
            <span class="apidocSignatureSpan">(keys, vals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.throwIf">
            function <span class="apidocSignatureSpan">reflux.</span>utils.throwIf
            <span class="apidocSignatureSpan">(val, msg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ActionMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>Component.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>GlobalState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ListenerMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ListenerMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>PublisherMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>Store.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>StoreMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>__keep</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>stores</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component">module reflux.Component</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.Component">
            function <span class="apidocSignatureSpan">reflux.</span>Component
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.extend">
            function <span class="apidocSignatureSpan">reflux.Component.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.extend">module reflux.Component.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.extend.extend">
            function <span class="apidocSignatureSpan">reflux.Component.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.prototype">module reflux.Component.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.Component.prototype.</span>storeKeys</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.prototype.componentWillMount">module reflux.Component.prototype.componentWillMount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillMount.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.prototype.componentWillUnmount">module reflux.Component.prototype.componentWillUnmount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillUnmount.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.prototype.mapStoreToState">module reflux.Component.prototype.mapStoreToState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.mapStoreToState.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods">module reflux.ListenerMethods</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.hasListener">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinConcat">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinLeading">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinStrict">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenToMany">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.validateListening">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.fetchInitialState">module reflux.ListenerMethods.fetchInitialState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.fetchInitialState.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.hasListener">module reflux.ListenerMethods.hasListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.hasListener.hasListener">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.joinConcat">module reflux.ListenerMethods.joinConcat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinConcat.joinConcat">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.joinLeading">module reflux.ListenerMethods.joinLeading</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinLeading.joinLeading">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.joinStrict">module reflux.ListenerMethods.joinStrict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinStrict.joinStrict">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.joinTrailing">module reflux.ListenerMethods.joinTrailing</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinTrailing.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.listenTo">module reflux.ListenerMethods.listenTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenTo.listenTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.listenToMany">module reflux.ListenerMethods.listenToMany</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenToMany.listenToMany">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.stopListeningTo">module reflux.ListenerMethods.stopListeningTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningTo.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.stopListeningToAll">module reflux.ListenerMethods.stopListeningToAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods.validateListening">module reflux.ListenerMethods.validateListening</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.validateListening.validateListening">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMixin">module reflux.ListenerMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.hasListener">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinConcat">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinLeading">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinStrict">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.listenTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.listenToMany">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.validateListening">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods">module reflux.PublisherMethods</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.deferWith">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.listen">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
            <span class="apidocSignatureSpan">(callback, bindContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.preEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.shouldEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.trigger">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.triggerAsync">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.deferWith">module reflux.PublisherMethods.deferWith</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.deferWith.deferWith">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.listen">module reflux.PublisherMethods.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.listen.listen">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
            <span class="apidocSignatureSpan">(callback, bindContext)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.preEmit">module reflux.PublisherMethods.preEmit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.preEmit.preEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.shouldEmit">module reflux.PublisherMethods.shouldEmit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.shouldEmit.shouldEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.trigger">module reflux.PublisherMethods.trigger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.trigger.trigger">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods.triggerAsync">module reflux.PublisherMethods.triggerAsync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.triggerAsync.triggerAsync">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent">module reflux.PureComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.PureComponent">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.extend">
            function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.extend">module reflux.PureComponent.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.extend.extend">
            function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.prototype">module reflux.PureComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>storeKeys</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.prototype.componentWillMount">module reflux.PureComponent.prototype.componentWillMount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.prototype.componentWillUnmount">module reflux.PureComponent.prototype.componentWillUnmount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.prototype.mapStoreToState">module reflux.PureComponent.prototype.mapStoreToState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Store">module reflux.Store</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.Store.</span>isES6Store</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.Store">
            function <span class="apidocSignatureSpan">reflux.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Store.prototype">module reflux.Store.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.prototype.setState">
            function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Store.prototype.setState">module reflux.Store.prototype.setState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.prototype.setState.setState">
            function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep">module reflux.__keep</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addAction">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
            <span class="apidocSignatureSpan">(act)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addStore">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.reset">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.useKeep">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.__keep.</span>createdActions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.__keep.</span>createdStores</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep.addAction">module reflux.__keep.addAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addAction.addAction">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
            <span class="apidocSignatureSpan">(act)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep.addStore">module reflux.__keep.addStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addStore.addStore">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep.reset">module reflux.__keep.reset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.reset.reset">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep.useKeep">module reflux.__keep.useKeep</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.useKeep.useKeep">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.connect">module reflux.connect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connect.connect">
            function <span class="apidocSignatureSpan">reflux.</span>connect
            <span class="apidocSignatureSpan">(listenable, key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.connectFilter">module reflux.connectFilter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connectFilter.connectFilter">
            function <span class="apidocSignatureSpan">reflux.</span>connectFilter
            <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.createAction">module reflux.createAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createAction.createAction">
            function <span class="apidocSignatureSpan">reflux.</span>createAction
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.createActions">module reflux.createActions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createActions.createActions">
            function <span class="apidocSignatureSpan">reflux.</span>createActions
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.createStore">module reflux.createStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createStore.createStore">
            function <span class="apidocSignatureSpan">reflux.</span>createStore
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.defineReact">module reflux.defineReact</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.defineReact.defineReact">
            function <span class="apidocSignatureSpan">reflux.</span>defineReact
            <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.getGlobalState">module reflux.getGlobalState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.getGlobalState.getGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.initStore">module reflux.initStore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.initStore.initStore">
            function <span class="apidocSignatureSpan">reflux.</span>initStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.joinConcat">module reflux.joinConcat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinConcat.joinConcat">
            function <span class="apidocSignatureSpan">reflux.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.joinLeading">module reflux.joinLeading</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinLeading.joinLeading">
            function <span class="apidocSignatureSpan">reflux.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.joinStrict">module reflux.joinStrict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinStrict.joinStrict">
            function <span class="apidocSignatureSpan">reflux.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.joinTrailing">module reflux.joinTrailing</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinTrailing.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.karma_conf">module reflux.karma_conf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.karma_conf.karma_conf">
            function <span class="apidocSignatureSpan">reflux.</span>karma_conf
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.listenTo">module reflux.listenTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenTo.listenTo">
            function <span class="apidocSignatureSpan">reflux.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.listenToMany">module reflux.listenToMany</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenToMany.listenToMany">
            function <span class="apidocSignatureSpan">reflux.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.nextTick">module reflux.nextTick</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.nextTick.nextTick">
            function <span class="apidocSignatureSpan">reflux.</span>nextTick
            <span class="apidocSignatureSpan">(nextTick)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.setEventEmitter">module reflux.setEventEmitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setEventEmitter.setEventEmitter">
            function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.setGlobalState">module reflux.setGlobalState</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setGlobalState.setGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.use">module reflux.use</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.use.use">
            function <span class="apidocSignatureSpan">reflux.</span>use
            <span class="apidocSignatureSpan">(pluginCb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils">module reflux.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.callbackName">
            function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
            <span class="apidocSignatureSpan">(string, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.capitalize">
            function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.extend">
            function <span class="apidocSignatureSpan">reflux.utils.</span>extend
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.inherits">
            function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
            <span class="apidocSignatureSpan">(subClass, superClass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isArguments">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isFunction">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isObject">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.nextTick">
            function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.object">
            function <span class="apidocSignatureSpan">reflux.utils.</span>object
            <span class="apidocSignatureSpan">(keys, vals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.throwIf">
            function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
            <span class="apidocSignatureSpan">(val, msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter">module reflux.utils.EventEmitter</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.utils.EventEmitter.</span>prefixed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype">module reflux.utils.EventEmitter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.addListener">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>addListener
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.off">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.on">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.once">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.emit">module reflux.utils.EventEmitter.prototype.emit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit.emit">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.eventNames">module reflux.utils.EventEmitter.prototype.eventNames</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames.eventNames">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.listeners">module reflux.utils.EventEmitter.prototype.listeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners.listeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.on">module reflux.utils.EventEmitter.prototype.on</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.on.on">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.once">module reflux.utils.EventEmitter.prototype.once</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.once.once">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.removeAllListeners">module reflux.utils.EventEmitter.prototype.removeAllListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners.removeAllListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.removeListener">module reflux.utils.EventEmitter.prototype.removeListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener.removeListener">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.setMaxListeners">module reflux.utils.EventEmitter.prototype.setMaxListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners.setMaxListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.callbackName">module reflux.utils.callbackName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.callbackName.callbackName">
            function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
            <span class="apidocSignatureSpan">(string, prefix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.capitalize">module reflux.utils.capitalize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.capitalize.capitalize">
            function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.extend">module reflux.utils.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.extend.extend">
            function <span class="apidocSignatureSpan">reflux.utils.</span>extend
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.inherits">module reflux.utils.inherits</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.inherits.inherits">
            function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
            <span class="apidocSignatureSpan">(subClass, superClass)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.isArguments">module reflux.utils.isArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isArguments.isArguments">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.isFunction">module reflux.utils.isFunction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isFunction.isFunction">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.isObject">module reflux.utils.isObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isObject.isObject">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.nextTick">module reflux.utils.nextTick</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.nextTick.nextTick">
            function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.object">module reflux.utils.object</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.object.object">
            function <span class="apidocSignatureSpan">reflux.utils.</span>object
            <span class="apidocSignatureSpan">(keys, vals)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.throwIf">module reflux.utils.throwIf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.throwIf.throwIf">
            function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
            <span class="apidocSignatureSpan">(val, msg)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux" id="apidoc.module.reflux">module reflux</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.Component" id="apidoc.element.reflux.Component">
        function <span class="apidocSignatureSpan">reflux.</span>Component
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.extend" id="apidoc.element.reflux.Component.extend">
        function <span class="apidocSignatureSpan">reflux.</span>Component.extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component.extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillMount" id="apidoc.element.reflux.Component.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component.prototype.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillUnmount" id="apidoc.element.reflux.Component.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component.prototype.componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.mapStoreToState" id="apidoc.element.reflux.Component.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.</span>Component.prototype.mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component.prototype.mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.fetchInitialState" id="apidoc.element.reflux.ListenerMethods.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &amp;&amp; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &amp;&amp; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &amp;&amp; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.hasListener" id="apidoc.element.reflux.ListenerMethods.hasListener">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &lt; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &lt; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &amp;&amp; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinConcat" id="apidoc.element.reflux.ListenerMethods.joinConcat">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListenerMethods.joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinLeading" id="apidoc.element.reflux.ListenerMethods.joinLeading">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListenerMethods.joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinStrict" id="apidoc.element.reflux.ListenerMethods.joinStrict">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListenerMethods.joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinTrailing" id="apidoc.element.reflux.ListenerMethods.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListenerMethods.joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenTo" id="apidoc.element.reflux.ListenerMethods.listenTo">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenToMany" id="apidoc.element.reflux.ListenerMethods.listenToMany">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningTo" id="apidoc.element.reflux.ListenerMethods.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &lt; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll" id="apidoc.element.reflux.ListenerMethods.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.validateListening" id="apidoc.element.reflux.ListenerMethods.validateListening">
        function <span class="apidocSignatureSpan">reflux.</span>ListenerMethods.validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener &amp;&amp; listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.deferWith" id="apidoc.element.reflux.PublisherMethods.deferWith">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.deferWith
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.listen" id="apidoc.element.reflux.PublisherMethods.listen">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.listen
        <span class="apidocSignatureSpan">(callback, bindContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.preEmit" id="apidoc.element.reflux.PublisherMethods.preEmit">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.preEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preEmit() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.shouldEmit" id="apidoc.element.reflux.PublisherMethods.shouldEmit">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.shouldEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldEmit() {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.trigger" id="apidoc.element.reflux.PublisherMethods.trigger">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.trigger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.triggerAsync" id="apidoc.element.reflux.PublisherMethods.triggerAsync">
        function <span class="apidocSignatureSpan">reflux.</span>PublisherMethods.triggerAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent" id="apidoc.element.reflux.PureComponent">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.extend" id="apidoc.element.reflux.PureComponent.extend">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent.extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent.extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount" id="apidoc.element.reflux.PureComponent.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent.prototype.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount" id="apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent.prototype.componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState" id="apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype.mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent.prototype.mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Store" id="apidoc.element.reflux.Store">
        function <span class="apidocSignatureSpan">reflux.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store = function () {
		// extending doesn't really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Store.prototype.setState" id="apidoc.element.reflux.Store.prototype.setState">
        function <span class="apidocSignatureSpan">reflux.</span>Store.prototype.setState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store.prototype.setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.addAction" id="apidoc.element.reflux.__keep.addAction">
        function <span class="apidocSignatureSpan">reflux.</span>__keep.addAction
        <span class="apidocSignatureSpan">(act)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.addStore" id="apidoc.element.reflux.__keep.addStore">
        function <span class="apidocSignatureSpan">reflux.</span>__keep.addStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.reset" id="apidoc.element.reflux.__keep.reset">
        function <span class="apidocSignatureSpan">reflux.</span>__keep.reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.useKeep" id="apidoc.element.reflux.__keep.useKeep">
        function <span class="apidocSignatureSpan">reflux.</span>__keep.useKeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useKeep() {
	var bool = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.all" id="apidoc.element.reflux.all">
        function <span class="apidocSignatureSpan">reflux.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.connect" id="apidoc.element.reflux.connect">
        function <span class="apidocSignatureSpan">reflux.</span>connect
        <span class="apidocSignatureSpan">(listenable, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (listenable, key) {

    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            return _.object([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
            var me = this;

            _.extend(me, ListenerMethods);

            this.listenTo(listenable, function(v) {
                me.setState(_.object([key],[v]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.connectFilter" id="apidoc.element.reflux.connectFilter">
        function <span class="apidocSignatureSpan">reflux.</span>connectFilter
        <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectFilter = function (listenable, key, filterFunc) {

    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            // Filter initial payload from store.
            var result = filterFunc.call(this, listenable.getInitialState());
            if (typeof(result) !== 'undefined') {
                return _.object([key], [result]);
            } else {
                return {};
            }
        },
        componentDidMount: function() {
            var me = this;

            _.extend(this, ListenerMethods);

            this.listenTo(listenable, function(value) {
                var result = filterFunc.call(me, value);
                me.setState(_.object([key], [result]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createAction" id="apidoc.element.reflux.createAction">
        function <span class="apidocSignatureSpan">reflux.</span>createAction
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAction(definition) {

    definition = definition || {};
    if (!_.isObject(definition)) {
        definition = { actionName: definition };
    }

    for (var a in ActionMethods) {
        if (!allowed[a] &amp;&amp; PublisherMethods[a]) {
            throw new Error("Cannot override API method " + a + " in Reflux.ActionMethods. Use another method name or override it
 on Reflux.PublisherMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] &amp;&amp; PublisherMethods[d]) {
            throw new Error("Cannot override API method " + d + " in action creation. Use another method name or override it on
Reflux.PublisherMethods instead.");
        }
    }

    definition.children = definition.children || [];
    if (definition.asyncResult) {
        definition.children = definition.children.concat(["completed", "failed"]);
    }

    var i = 0,
        childActions = {};
    for (; i &lt; definition.children.length; i++) {
        var chDef = definition.children[i];
        var chName = typeof chDef === "string" ? chDef : chDef.actionName;
        childActions[chName] = createAction(chDef);
    }

    var context = _.extend({
        eventLabel: "action",
        emitter: new _.EventEmitter(),
        _isAction: true
    }, PublisherMethods, ActionMethods, definition);

    var functor = function functor() {
        var hasChildActions = false;
<span class="apidocCodeCommentSpan">        /* eslint no-unused-vars:0 */
</span>        for (var ignore in functor.childActions) {
            hasChildActions = true;break;
        }
        var async = !functor.sync &amp;&amp; typeof functor.sync !== "undefined" || hasChildActions;
        var triggerType = async ? "triggerAsync" : "trigger";
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.addAction(functor);

    return functor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
--------------------------------

## Creating Actions

Create an action by calling `Reflux.createAction` with an optional options object.

```javascript
var statusUpdate = Reflux.<span class="apidocCodeKeywordSpan">createAction</span>();
```

An action is a [function object](http://en.wikipedia.org/wiki/Function_object) that can be invoked like any other function.

```javascript
statusUpdate(data); // Invokes the action statusUpdate
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createActions" id="apidoc.element.reflux.createActions">
        function <span class="apidocSignatureSpan">reflux.</span>createActions
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createActions = function (definitions) {
    var actions = {};
    if (definitions instanceof Array) {
        definitions.forEach(function (val) {
            if (_.isObject(val)) {
                reducer(val, actions);
            } else {
                actions[val] = (0, _createAction.createAction)(val);
            }
        });
    } else {
        reducer(definitions, actions);
    }
    return actions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
statusUpdate(data); // Invokes the action statusUpdate
```

There is also a convenience function for creating multiple actions.

```javascript
var Actions = Reflux.<span class="apidocCodeKeywordSpan">createActions</span>([
    "statusUpdate",
    "statusEdited",
    "statusAdded"
]);

// Actions object now contains the actions
// with the names given in the array above
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createStore" id="apidoc.element.reflux.createStore">
        function <span class="apidocSignatureSpan">reflux.</span>createStore
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStore(definition) {

    definition = definition || {};

    for (var a in StoreMethods) {
        if (!allowed[a] &amp;&amp; (PublisherMethods[a] || ListenerMethods[a])) {
            throw new Error("Cannot override API method " + a + " in Reflux.StoreMethods. Use another method name or override it
 on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] &amp;&amp; (PublisherMethods[d] || ListenerMethods[d])) {
            throw new Error("Cannot override API method " + d + " in store creation. Use another method name or override it on Reflux
.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    definition = (0, _mixer.mix)(definition);

    function Store() {
        var i = 0,
            arr;
        this.subscriptions = [];
        this.emitter = new _.EventEmitter();
        this.eventLabel = "change";
        (0, _bindMethods.bindMethods)(this, definition);
        if (this.init &amp;&amp; _.isFunction(this.init)) {
            this.init();
        }
        if (this.listenables) {
            arr = [].concat(this.listenables);
            for (; i &lt; arr.length; i++) {
                this.listenToMany(arr[i]);
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.addStore(store);

    return store;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.defineReact" id="apidoc.element.reflux.defineReact">
        function <span class="apidocSignatureSpan">reflux.</span>defineReact
        <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineReact(react, noLongerUsed, extend)
{
	var proto, _extend;
	
	// if no Reflux object is yet available then return and just wait until defineReact is called manually with it
	try {
		_react  = react  || _react  || React;
		_extend = extend || _react.Component;
	} catch (e) {
		return;
	}
	
	// if Reflux and React aren't present then ignore, wait until they are properly present
	// also ignore if it's been called before UNLESS there's manual extending happening
	if (!_react || !_extend || (_defined &amp;&amp; !extend)) {
		return;
	}
	
	// ----------- BEGIN Reflux.Component ------------
	/**
	 * Reflux.Component:
	 * An implementation for idiomatic React.js classes that mix with
	 * Reflux stores. To utilize extend Reflux.Component instead of
	 * React.Component. Then you may hook any Reflux store that has a
	 * `this.state` property containing its state values to the component
	 * via `this.store` or an Array of Reflux stores via `this.stores` in
	 * the component's constructor (similar to how you assign initial state
	 * in the constructor in ES6 style React). The default values of the
	 * stores will automatically reflect in the component's state, and any
	 * further `trigger` calls from that store will update properties passed
	 * in the trigger into the component automatically.
	 */
	var RefluxComponent = function(props, context, updater) {
		_extend.call(this, props, context, updater);
	};
	
	// equivalent of `extends React.Component` or other class if provided via `extend` param
	Reflux.utils.inherits(RefluxComponent, _extend);
	
	proto = RefluxComponent.prototype;
	
	/**
	 * this.storeKeys
	 * When this is a falsey value (null by default) the component mixes in
	 * all properties from the stores attached to it and updates on changes
	 * from all of them. When set to an array of string keys it will only
	 * utilized state property names of those keys in any store attached. This
	 * lets you choose which parts of stores update the component on a component-
	 * by-component basis. If using this it is best set in the constructor.
	 */
	proto.storeKeys = null;
	
	// on the mounting of the component that is where the store/stores are attached and initialized if needed
	proto.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			subClass.__proto__ = superClass;
		}
	}
};

// first try to see if there's a global React var and use it
if (typeof React !== 'undefined' &amp;&amp; React) {
	Reflux.<span class="apidocCodeKeywordSpan">defineReact</span>(React);
// otherwise we're gonna resort to 'try' stuff in case of other environments
} else {
	try {
		var R = require("react"); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck
 for in node
		Reflux.defineReact(R);
	} catch (e) {}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.getGlobalState" id="apidoc.element.reflux.getGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getGlobalState = function () {
		return clone(Reflux.GlobalState);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.initStore" id="apidoc.element.reflux.initStore">
        function <span class="apidocSignatureSpan">reflux.</span>initStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initStore = function (str) {
		var storeId = str.id;
		// if they're initializing something twice then we're done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it's easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class's singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.initializeGlobalStore" id="apidoc.element.reflux.initializeGlobalStore">
        function <span class="apidocSignatureSpan">reflux.</span>initializeGlobalStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeGlobalStore = function (str) {
		var storeId = str.id;
		// if they're initializing something twice then we're done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it's easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class's singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinConcat" id="apidoc.element.reflux.joinConcat">
        function <span class="apidocSignatureSpan">reflux.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinLeading" id="apidoc.element.reflux.joinLeading">
        function <span class="apidocSignatureSpan">reflux.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinStrict" id="apidoc.element.reflux.joinStrict">
        function <span class="apidocSignatureSpan">reflux.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinTrailing" id="apidoc.element.reflux.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.karma_conf" id="apidoc.element.reflux.karma_conf">
        function <span class="apidocSignatureSpan">reflux.</span>karma_conf
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">karma_conf = function (config) {
    config.set({
        logLevel: 'LOG_DEBUG',

        reporters: ['spec'],

        singleRun : true,
        autoWatch : false,

        frameworks: [
            'mocha',
            'browserify'
        ],

        files: [
            'test/shims/phantomjs-shims.js',
            'test/*.spec.js'
        ],

        preprocessors: {
            'test/shims/phantomjs-shims.js': ['browserify'],
            'test/*.spec.js': ['browserify']
        },

        browserify: {
            debug: true
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.listenTo" id="apidoc.element.reflux.listenTo">
        function <span class="apidocSignatureSpan">reflux.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenTo = function (listenable, callback, initial){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenTo!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenTo(listenable,callback,initial);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
class StatusStore extends Reflux.Store
{
constructor()
{
    super();
    this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
    this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
}

onStatusUpdate(status)
{
    var newFlag = status ? 'ONLINE' : 'OFFLINE';
    this.setState({flag:newFlag});
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.listenToMany" id="apidoc.element.reflux.listenToMany">
        function <span class="apidocSignatureSpan">reflux.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenToMany = function (listenables){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenToMany!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenToMany(listenables);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.nextTick" id="apidoc.element.reflux.nextTick">
        function <span class="apidocSignatureSpan">reflux.</span>nextTick
        <span class="apidocSignatureSpan">(nextTick)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(nextTick) {
    _.nextTick = nextTick;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.setEventEmitter" id="apidoc.element.reflux.setEventEmitter">
        function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setEventEmitter(ctx) {
    _.EventEmitter = ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.setGlobalState" id="apidoc.element.reflux.setGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setGlobalState = function (obj) {
		for (var storeID in obj) {
			if (Reflux.stores[storeID]) {
				Reflux.stores[storeID].setState(obj[storeID]);
			} else {
				Reflux.GlobalState[storeID] = obj[storeID];
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.use" id="apidoc.element.reflux.use">
        function <span class="apidocSignatureSpan">reflux.</span>use
        <span class="apidocSignatureSpan">(pluginCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(pluginCb) {
    pluginCb(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit" id="apidoc.element.reflux.utils.EventEmitter.prototype.emit">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &lt; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &lt; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &lt; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames" id="apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &amp;&amp; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &lt; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.on" id="apidoc.element.reflux.utils.EventEmitter.prototype.on">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.once" id="apidoc.element.reflux.utils.EventEmitter.prototype.once">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype.setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.callbackName" id="apidoc.element.reflux.utils.callbackName">
        function <span class="apidocSignatureSpan">reflux.</span>utils.callbackName
        <span class="apidocSignatureSpan">(string, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function callbackName(string, prefix) {
    prefix = prefix || "on";
    return prefix + exports.capitalize(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.capitalize" id="apidoc.element.reflux.utils.capitalize">
        function <span class="apidocSignatureSpan">reflux.</span>utils.capitalize
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.extend" id="apidoc.element.reflux.utils.extend">
        function <span class="apidocSignatureSpan">reflux.</span>utils.extend
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i &lt; length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j &lt; keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor &amp;&amp; Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.inherits" id="apidoc.element.reflux.utils.inherits">
        function <span class="apidocSignatureSpan">reflux.</span>utils.inherits
        <span class="apidocSignatureSpan">(subClass, superClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utils.inherits = function (subClass, superClass) {
	if (typeof superClass !== "function" &amp;&amp; superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}
	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isArguments" id="apidoc.element.reflux.utils.isArguments">
        function <span class="apidocSignatureSpan">reflux.</span>utils.isArguments
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArguments(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" &amp;&amp; "callee" in value &amp;&amp; typeof value.length
 === "number";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isFunction" id="apidoc.element.reflux.utils.isFunction">
        function <span class="apidocSignatureSpan">reflux.</span>utils.isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(value) {
    return typeof value === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isObject" id="apidoc.element.reflux.utils.isObject">
        function <span class="apidocSignatureSpan">reflux.</span>utils.isObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return type === "function" || type === "object" &amp;&amp; !!obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.nextTick" id="apidoc.element.reflux.utils.nextTick">
        function <span class="apidocSignatureSpan">reflux.</span>utils.nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
    setTimeout(callback, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.object" id="apidoc.element.reflux.utils.object">
        function <span class="apidocSignatureSpan">reflux.</span>utils.object
        <span class="apidocSignatureSpan">(keys, vals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i &lt; keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.throwIf" id="apidoc.element.reflux.utils.throwIf">
        function <span class="apidocSignatureSpan">reflux.</span>utils.throwIf
        <span class="apidocSignatureSpan">(val, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component" id="apidoc.module.reflux.Component">module reflux.Component</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.Component" id="apidoc.element.reflux.Component.Component">
        function <span class="apidocSignatureSpan">reflux.</span>Component
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.extend" id="apidoc.element.reflux.Component.extend">
        function <span class="apidocSignatureSpan">reflux.Component.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.extend" id="apidoc.module.reflux.Component.extend">module reflux.Component.extend</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.extend.extend" id="apidoc.element.reflux.Component.extend.extend">
        function <span class="apidocSignatureSpan">reflux.Component.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.prototype" id="apidoc.module.reflux.Component.prototype">module reflux.Component.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillMount" id="apidoc.element.reflux.Component.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillUnmount" id="apidoc.element.reflux.Component.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.mapStoreToState" id="apidoc.element.reflux.Component.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.prototype.componentWillMount" id="apidoc.module.reflux.Component.prototype.componentWillMount">module reflux.Component.prototype.componentWillMount</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillMount.componentWillMount" id="apidoc.element.reflux.Component.prototype.componentWillMount.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.prototype.componentWillUnmount" id="apidoc.module.reflux.Component.prototype.componentWillUnmount">module reflux.Component.prototype.componentWillUnmount</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillUnmount.componentWillUnmount" id="apidoc.element.reflux.Component.prototype.componentWillUnmount.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.prototype.mapStoreToState" id="apidoc.module.reflux.Component.prototype.mapStoreToState">module reflux.Component.prototype.mapStoreToState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.mapStoreToState.mapStoreToState" id="apidoc.element.reflux.Component.prototype.mapStoreToState.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods" id="apidoc.module.reflux.ListenerMethods">module reflux.ListenerMethods</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.fetchInitialState" id="apidoc.element.reflux.ListenerMethods.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &amp;&amp; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &amp;&amp; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &amp;&amp; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.hasListener" id="apidoc.element.reflux.ListenerMethods.hasListener">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &lt; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &lt; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &amp;&amp; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinConcat" id="apidoc.element.reflux.ListenerMethods.joinConcat">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinLeading" id="apidoc.element.reflux.ListenerMethods.joinLeading">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinStrict" id="apidoc.element.reflux.ListenerMethods.joinStrict">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinTrailing" id="apidoc.element.reflux.ListenerMethods.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenTo" id="apidoc.element.reflux.ListenerMethods.listenTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
class StatusStore extends Reflux.Store
{
constructor()
{
    super();
    this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
    this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
}

onStatusUpdate(status)
{
    var newFlag = status ? 'ONLINE' : 'OFFLINE';
    this.setState({flag:newFlag});
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenToMany" id="apidoc.element.reflux.ListenerMethods.listenToMany">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningTo" id="apidoc.element.reflux.ListenerMethods.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &lt; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll" id="apidoc.element.reflux.ListenerMethods.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.validateListening" id="apidoc.element.reflux.ListenerMethods.validateListening">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener &amp;&amp; listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.fetchInitialState" id="apidoc.module.reflux.ListenerMethods.fetchInitialState">module reflux.ListenerMethods.fetchInitialState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.fetchInitialState.fetchInitialState" id="apidoc.element.reflux.ListenerMethods.fetchInitialState.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &amp;&amp; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &amp;&amp; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &amp;&amp; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.hasListener" id="apidoc.module.reflux.ListenerMethods.hasListener">module reflux.ListenerMethods.hasListener</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.hasListener.hasListener" id="apidoc.element.reflux.ListenerMethods.hasListener.hasListener">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &lt; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &lt; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &amp;&amp; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.joinConcat" id="apidoc.module.reflux.ListenerMethods.joinConcat">module reflux.ListenerMethods.joinConcat</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinConcat.joinConcat" id="apidoc.element.reflux.ListenerMethods.joinConcat.joinConcat">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.joinLeading" id="apidoc.module.reflux.ListenerMethods.joinLeading">module reflux.ListenerMethods.joinLeading</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinLeading.joinLeading" id="apidoc.element.reflux.ListenerMethods.joinLeading.joinLeading">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.joinStrict" id="apidoc.module.reflux.ListenerMethods.joinStrict">module reflux.ListenerMethods.joinStrict</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinStrict.joinStrict" id="apidoc.element.reflux.ListenerMethods.joinStrict.joinStrict">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.joinTrailing" id="apidoc.module.reflux.ListenerMethods.joinTrailing">module reflux.ListenerMethods.joinTrailing</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinTrailing.joinTrailing" id="apidoc.element.reflux.ListenerMethods.joinTrailing.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.listenTo" id="apidoc.module.reflux.ListenerMethods.listenTo">module reflux.ListenerMethods.listenTo</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenTo.listenTo" id="apidoc.element.reflux.ListenerMethods.listenTo.listenTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
class StatusStore extends Reflux.Store
{
constructor()
{
    super();
    this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
    this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
}

onStatusUpdate(status)
{
    var newFlag = status ? 'ONLINE' : 'OFFLINE';
    this.setState({flag:newFlag});
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.listenToMany" id="apidoc.module.reflux.ListenerMethods.listenToMany">module reflux.ListenerMethods.listenToMany</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenToMany.listenToMany" id="apidoc.element.reflux.ListenerMethods.listenToMany.listenToMany">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.stopListeningTo" id="apidoc.module.reflux.ListenerMethods.stopListeningTo">module reflux.ListenerMethods.stopListeningTo</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningTo.stopListeningTo" id="apidoc.element.reflux.ListenerMethods.stopListeningTo.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &lt; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.stopListeningToAll" id="apidoc.module.reflux.ListenerMethods.stopListeningToAll">module reflux.ListenerMethods.stopListeningToAll</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll.stopListeningToAll" id="apidoc.element.reflux.ListenerMethods.stopListeningToAll.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods.validateListening" id="apidoc.module.reflux.ListenerMethods.validateListening">module reflux.ListenerMethods.validateListening</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.validateListening.validateListening" id="apidoc.element.reflux.ListenerMethods.validateListening.validateListening">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener &amp;&amp; listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMixin" id="apidoc.module.reflux.ListenerMixin">module reflux.ListenerMixin</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.componentWillUnmount" id="apidoc.element.reflux.ListenerMixin.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.fetchInitialState" id="apidoc.element.reflux.ListenerMixin.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &amp;&amp; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &amp;&amp; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &amp;&amp; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.hasListener" id="apidoc.element.reflux.ListenerMixin.hasListener">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &lt; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &lt; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &amp;&amp; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinConcat" id="apidoc.element.reflux.ListenerMixin.joinConcat">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinLeading" id="apidoc.element.reflux.ListenerMixin.joinLeading">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinStrict" id="apidoc.element.reflux.ListenerMixin.joinStrict">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinTrailing" id="apidoc.element.reflux.ListenerMixin.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &lt; 2, "Cannot create a join with less than 2 listenables!");
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &lt; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &lt; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.listenTo" id="apidoc.element.reflux.ListenerMixin.listenTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
class StatusStore extends Reflux.Store
{
constructor()
{
    super();
    this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
    this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
}

onStatusUpdate(status)
{
    var newFlag = status ? 'ONLINE' : 'OFFLINE';
    this.setState({flag:newFlag});
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.listenToMany" id="apidoc.element.reflux.ListenerMixin.listenToMany">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.stopListeningTo" id="apidoc.element.reflux.ListenerMixin.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &lt; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.stopListeningToAll" id="apidoc.element.reflux.ListenerMixin.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.validateListening" id="apidoc.element.reflux.ListenerMixin.validateListening">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return "Listener is not able to listen to itself";
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + " is missing a listen method";
    }
    if (listenable.hasListener &amp;&amp; listenable.hasListener(this)) {
        return "Listener cannot listen to this listenable because of circular loop";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods" id="apidoc.module.reflux.PublisherMethods">module reflux.PublisherMethods</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.deferWith" id="apidoc.element.reflux.PublisherMethods.deferWith">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.listen" id="apidoc.element.reflux.PublisherMethods.listen">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
        <span class="apidocSignatureSpan">(callback, bindContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.preEmit" id="apidoc.element.reflux.PublisherMethods.preEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preEmit() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.shouldEmit" id="apidoc.element.reflux.PublisherMethods.shouldEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldEmit() {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.trigger" id="apidoc.element.reflux.PublisherMethods.trigger">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.triggerAsync" id="apidoc.element.reflux.PublisherMethods.triggerAsync">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.deferWith" id="apidoc.module.reflux.PublisherMethods.deferWith">module reflux.PublisherMethods.deferWith</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.deferWith.deferWith" id="apidoc.element.reflux.PublisherMethods.deferWith.deferWith">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.listen" id="apidoc.module.reflux.PublisherMethods.listen">module reflux.PublisherMethods.listen</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.listen.listen" id="apidoc.element.reflux.PublisherMethods.listen.listen">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
        <span class="apidocSignatureSpan">(callback, bindContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.preEmit" id="apidoc.module.reflux.PublisherMethods.preEmit">module reflux.PublisherMethods.preEmit</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.preEmit.preEmit" id="apidoc.element.reflux.PublisherMethods.preEmit.preEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preEmit() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.shouldEmit" id="apidoc.module.reflux.PublisherMethods.shouldEmit">module reflux.PublisherMethods.shouldEmit</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.shouldEmit.shouldEmit" id="apidoc.element.reflux.PublisherMethods.shouldEmit.shouldEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldEmit() {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.trigger" id="apidoc.module.reflux.PublisherMethods.trigger">module reflux.PublisherMethods.trigger</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.trigger.trigger" id="apidoc.element.reflux.PublisherMethods.trigger.trigger">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods.triggerAsync" id="apidoc.module.reflux.PublisherMethods.triggerAsync">module reflux.PublisherMethods.triggerAsync</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.triggerAsync.triggerAsync" id="apidoc.element.reflux.PublisherMethods.triggerAsync.triggerAsync">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent" id="apidoc.module.reflux.PureComponent">module reflux.PureComponent</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.PureComponent" id="apidoc.element.reflux.PureComponent.PureComponent">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.extend" id="apidoc.element.reflux.PureComponent.extend">
        function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.extend" id="apidoc.module.reflux.PureComponent.extend">module reflux.PureComponent.extend</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.extend.extend" id="apidoc.element.reflux.PureComponent.extend.extend">
        function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.prototype" id="apidoc.module.reflux.PureComponent.prototype">module reflux.PureComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount" id="apidoc.element.reflux.PureComponent.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount" id="apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState" id="apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.prototype.componentWillMount" id="apidoc.module.reflux.PureComponent.prototype.componentWillMount">module reflux.PureComponent.prototype.componentWillMount</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount.componentWillMount" id="apidoc.element.reflux.PureComponent.prototype.componentWillMount.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &amp;&amp; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the ".trigger()" in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&lt;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.prototype.componentWillUnmount" id="apidoc.module.reflux.PureComponent.prototype.componentWillUnmount">module reflux.PureComponent.prototype.componentWillUnmount</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount.componentWillUnmount" id="apidoc.element.reflux.PureComponent.prototype.componentWillUnmount.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &lt; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.prototype.mapStoreToState" id="apidoc.module.reflux.PureComponent.prototype.mapStoreToState">module reflux.PureComponent.prototype.mapStoreToState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState.mapStoreToState" id="apidoc.element.reflux.PureComponent.prototype.mapStoreToState.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === 'function') {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Store" id="apidoc.module.reflux.Store">module reflux.Store</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.Store.Store" id="apidoc.element.reflux.Store.Store">
        function <span class="apidocSignatureSpan">reflux.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store = function () {
		// extending doesn't really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Store.prototype" id="apidoc.module.reflux.Store.prototype">module reflux.Store.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Store.prototype.setState" id="apidoc.element.reflux.Store.prototype.setState">
        function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
        this.listenTo(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
    }

    onStatusUpdate(status)
    {
        var newFlag = status ? 'ONLINE' : 'OFFLINE';
        this.<span class="apidocCodeKeywordSpan">setState</span>({flag:newFlag});
    }
}
```

In the above example, whenever the action `statusUpdate` is called, the store's `onStatusUpdate` callback will be called with
 whatever parameters were sent in the action. E.g. if the action is called as `statusUpdate(true)` then the `status` argument in
 the `onStatusUpdate` function is `true`.

Stores also integrate easily with sets of actions via things like `this.listenables`. When an actions object (or an Array of multiple
 actions objects) is applied to `this.listenables` you may automatically add listeners simply by naming convention. Just name the
 functions either after the action name (such as `actionName`, or the camelcased action name preceded with "on", (such
 as `onActionName`).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Store.prototype.setState" id="apidoc.module.reflux.Store.prototype.setState">module reflux.Store.prototype.setState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Store.prototype.setState.setState" id="apidoc.element.reflux.Store.prototype.setState.setState">
        function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there's an id (i.e. it's being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it's attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
        this.listenTo(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
    }

    onStatusUpdate(status)
    {
        var newFlag = status ? 'ONLINE' : 'OFFLINE';
        this.<span class="apidocCodeKeywordSpan">setState</span>({flag:newFlag});
    }
}
```

In the above example, whenever the action `statusUpdate` is called, the store's `onStatusUpdate` callback will be called with
 whatever parameters were sent in the action. E.g. if the action is called as `statusUpdate(true)` then the `status` argument in
 the `onStatusUpdate` function is `true`.

Stores also integrate easily with sets of actions via things like `this.listenables`. When an actions object (or an Array of multiple
 actions objects) is applied to `this.listenables` you may automatically add listeners simply by naming convention. Just name the
 functions either after the action name (such as `actionName`, or the camelcased action name preceded with "on", (such
 as `onActionName`).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep" id="apidoc.module.reflux.__keep">module reflux.__keep</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.addAction" id="apidoc.element.reflux.__keep.addAction">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
        <span class="apidocSignatureSpan">(act)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.addStore" id="apidoc.element.reflux.__keep.addStore">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.reset" id="apidoc.element.reflux.__keep.reset">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.useKeep" id="apidoc.element.reflux.__keep.useKeep">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useKeep() {
	var bool = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep.addAction" id="apidoc.module.reflux.__keep.addAction">module reflux.__keep.addAction</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.addAction.addAction" id="apidoc.element.reflux.__keep.addAction.addAction">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
        <span class="apidocSignatureSpan">(act)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep.addStore" id="apidoc.module.reflux.__keep.addStore">module reflux.__keep.addStore</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.addStore.addStore" id="apidoc.element.reflux.__keep.addStore.addStore">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep.reset" id="apidoc.module.reflux.__keep.reset">module reflux.__keep.reset</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.reset.reset" id="apidoc.element.reflux.__keep.reset.reset">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep.useKeep" id="apidoc.module.reflux.__keep.useKeep">module reflux.__keep.useKeep</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.useKeep.useKeep" id="apidoc.element.reflux.__keep.useKeep.useKeep">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useKeep() {
	var bool = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.connect" id="apidoc.module.reflux.connect">module reflux.connect</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.connect.connect" id="apidoc.element.reflux.connect.connect">
        function <span class="apidocSignatureSpan">reflux.</span>connect
        <span class="apidocSignatureSpan">(listenable, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (listenable, key) {

    _.throwIf(typeof(key) === 'undefined', 'Reflux.connect() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            return _.object([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
            var me = this;

            _.extend(me, ListenerMethods);

            this.listenTo(listenable, function(v) {
                me.setState(_.object([key],[v]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.connectFilter" id="apidoc.module.reflux.connectFilter">module reflux.connectFilter</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.connectFilter.connectFilter" id="apidoc.element.reflux.connectFilter.connectFilter">
        function <span class="apidocSignatureSpan">reflux.</span>connectFilter
        <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectFilter = function (listenable, key, filterFunc) {

    _.throwIf(_.isFunction(key), 'Reflux.connectFilter() requires a key.');

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            // Filter initial payload from store.
            var result = filterFunc.call(this, listenable.getInitialState());
            if (typeof(result) !== 'undefined') {
                return _.object([key], [result]);
            } else {
                return {};
            }
        },
        componentDidMount: function() {
            var me = this;

            _.extend(this, ListenerMethods);

            this.listenTo(listenable, function(value) {
                var result = filterFunc.call(me, value);
                me.setState(_.object([key], [result]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.createAction" id="apidoc.module.reflux.createAction">module reflux.createAction</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.createAction.createAction" id="apidoc.element.reflux.createAction.createAction">
        function <span class="apidocSignatureSpan">reflux.</span>createAction
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAction(definition) {

    definition = definition || {};
    if (!_.isObject(definition)) {
        definition = { actionName: definition };
    }

    for (var a in ActionMethods) {
        if (!allowed[a] &amp;&amp; PublisherMethods[a]) {
            throw new Error("Cannot override API method " + a + " in Reflux.ActionMethods. Use another method name or override it
 on Reflux.PublisherMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] &amp;&amp; PublisherMethods[d]) {
            throw new Error("Cannot override API method " + d + " in action creation. Use another method name or override it on
Reflux.PublisherMethods instead.");
        }
    }

    definition.children = definition.children || [];
    if (definition.asyncResult) {
        definition.children = definition.children.concat(["completed", "failed"]);
    }

    var i = 0,
        childActions = {};
    for (; i &lt; definition.children.length; i++) {
        var chDef = definition.children[i];
        var chName = typeof chDef === "string" ? chDef : chDef.actionName;
        childActions[chName] = createAction(chDef);
    }

    var context = _.extend({
        eventLabel: "action",
        emitter: new _.EventEmitter(),
        _isAction: true
    }, PublisherMethods, ActionMethods, definition);

    var functor = function functor() {
        var hasChildActions = false;
<span class="apidocCodeCommentSpan">        /* eslint no-unused-vars:0 */
</span>        for (var ignore in functor.childActions) {
            hasChildActions = true;break;
        }
        var async = !functor.sync &amp;&amp; typeof functor.sync !== "undefined" || hasChildActions;
        var triggerType = async ? "triggerAsync" : "trigger";
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.addAction(functor);

    return functor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
--------------------------------

## Creating Actions

Create an action by calling `Reflux.createAction` with an optional options object.

```javascript
var statusUpdate = Reflux.<span class="apidocCodeKeywordSpan">createAction</span>();
```

An action is a [function object](http://en.wikipedia.org/wiki/Function_object) that can be invoked like any other function.

```javascript
statusUpdate(data); // Invokes the action statusUpdate
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.createActions" id="apidoc.module.reflux.createActions">module reflux.createActions</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.createActions.createActions" id="apidoc.element.reflux.createActions.createActions">
        function <span class="apidocSignatureSpan">reflux.</span>createActions
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createActions = function (definitions) {
    var actions = {};
    if (definitions instanceof Array) {
        definitions.forEach(function (val) {
            if (_.isObject(val)) {
                reducer(val, actions);
            } else {
                actions[val] = (0, _createAction.createAction)(val);
            }
        });
    } else {
        reducer(definitions, actions);
    }
    return actions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
statusUpdate(data); // Invokes the action statusUpdate
```

There is also a convenience function for creating multiple actions.

```javascript
var Actions = Reflux.<span class="apidocCodeKeywordSpan">createActions</span>([
    "statusUpdate",
    "statusEdited",
    "statusAdded"
]);

// Actions object now contains the actions
// with the names given in the array above
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.createStore" id="apidoc.module.reflux.createStore">module reflux.createStore</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.createStore.createStore" id="apidoc.element.reflux.createStore.createStore">
        function <span class="apidocSignatureSpan">reflux.</span>createStore
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStore(definition) {

    definition = definition || {};

    for (var a in StoreMethods) {
        if (!allowed[a] &amp;&amp; (PublisherMethods[a] || ListenerMethods[a])) {
            throw new Error("Cannot override API method " + a + " in Reflux.StoreMethods. Use another method name or override it
 on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    for (var d in definition) {
        if (!allowed[d] &amp;&amp; (PublisherMethods[d] || ListenerMethods[d])) {
            throw new Error("Cannot override API method " + d + " in store creation. Use another method name or override it on Reflux
.PublisherMethods / Reflux.ListenerMethods instead.");
        }
    }

    definition = (0, _mixer.mix)(definition);

    function Store() {
        var i = 0,
            arr;
        this.subscriptions = [];
        this.emitter = new _.EventEmitter();
        this.eventLabel = "change";
        (0, _bindMethods.bindMethods)(this, definition);
        if (this.init &amp;&amp; _.isFunction(this.init)) {
            this.init();
        }
        if (this.listenables) {
            arr = [].concat(this.listenables);
            for (; i &lt; arr.length; i++) {
                this.listenToMany(arr[i]);
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.addStore(store);

    return store;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.defineReact" id="apidoc.module.reflux.defineReact">module reflux.defineReact</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.defineReact.defineReact" id="apidoc.element.reflux.defineReact.defineReact">
        function <span class="apidocSignatureSpan">reflux.</span>defineReact
        <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineReact(react, noLongerUsed, extend)
{
	var proto, _extend;
	
	// if no Reflux object is yet available then return and just wait until defineReact is called manually with it
	try {
		_react  = react  || _react  || React;
		_extend = extend || _react.Component;
	} catch (e) {
		return;
	}
	
	// if Reflux and React aren't present then ignore, wait until they are properly present
	// also ignore if it's been called before UNLESS there's manual extending happening
	if (!_react || !_extend || (_defined &amp;&amp; !extend)) {
		return;
	}
	
	// ----------- BEGIN Reflux.Component ------------
	/**
	 * Reflux.Component:
	 * An implementation for idiomatic React.js classes that mix with
	 * Reflux stores. To utilize extend Reflux.Component instead of
	 * React.Component. Then you may hook any Reflux store that has a
	 * `this.state` property containing its state values to the component
	 * via `this.store` or an Array of Reflux stores via `this.stores` in
	 * the component's constructor (similar to how you assign initial state
	 * in the constructor in ES6 style React). The default values of the
	 * stores will automatically reflect in the component's state, and any
	 * further `trigger` calls from that store will update properties passed
	 * in the trigger into the component automatically.
	 */
	var RefluxComponent = function(props, context, updater) {
		_extend.call(this, props, context, updater);
	};
	
	// equivalent of `extends React.Component` or other class if provided via `extend` param
	Reflux.utils.inherits(RefluxComponent, _extend);
	
	proto = RefluxComponent.prototype;
	
	/**
	 * this.storeKeys
	 * When this is a falsey value (null by default) the component mixes in
	 * all properties from the stores attached to it and updates on changes
	 * from all of them. When set to an array of string keys it will only
	 * utilized state property names of those keys in any store attached. This
	 * lets you choose which parts of stores update the component on a component-
	 * by-component basis. If using this it is best set in the constructor.
	 */
	proto.storeKeys = null;
	
	// on the mounting of the component that is where the store/stores are attached and initialized if needed
	proto.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what's updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &lt; ii; i++) {
				var str = this.stores[i];
				// if's a function then we know it's a class getting passed, not an instance
				if (typeof str === 'function') {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren't sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it's the instance we're working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			subClass.__proto__ = superClass;
		}
	}
};

// first try to see if there's a global React var and use it
if (typeof React !== 'undefined' &amp;&amp; React) {
	Reflux.<span class="apidocCodeKeywordSpan">defineReact</span>(React);
// otherwise we're gonna resort to 'try' stuff in case of other environments
} else {
	try {
		var R = require("react"); // we ignore this in browserify manually (see grunt file), so it's more of a doublecheck
 for in node
		Reflux.defineReact(R);
	} catch (e) {}
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.getGlobalState" id="apidoc.module.reflux.getGlobalState">module reflux.getGlobalState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.getGlobalState.getGlobalState" id="apidoc.element.reflux.getGlobalState.getGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getGlobalState = function () {
		return clone(Reflux.GlobalState);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.initStore" id="apidoc.module.reflux.initStore">module reflux.initStore</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.initStore.initStore" id="apidoc.element.reflux.initStore.initStore">
        function <span class="apidocSignatureSpan">reflux.</span>initStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initStore = function (str) {
		var storeId = str.id;
		// if they're initializing something twice then we're done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it's easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class's singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.joinConcat" id="apidoc.module.reflux.joinConcat">module reflux.joinConcat</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.joinConcat.joinConcat" id="apidoc.element.reflux.joinConcat.joinConcat">
        function <span class="apidocSignatureSpan">reflux.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.joinLeading" id="apidoc.module.reflux.joinLeading">module reflux.joinLeading</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.joinLeading.joinLeading" id="apidoc.element.reflux.joinLeading.joinLeading">
        function <span class="apidocSignatureSpan">reflux.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.joinStrict" id="apidoc.module.reflux.joinStrict">module reflux.joinStrict</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.joinStrict.joinStrict" id="apidoc.element.reflux.joinStrict.joinStrict">
        function <span class="apidocSignatureSpan">reflux.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.joinTrailing" id="apidoc.module.reflux.joinTrailing">module reflux.joinTrailing</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.joinTrailing.joinTrailing" id="apidoc.element.reflux.joinTrailing.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.karma_conf" id="apidoc.module.reflux.karma_conf">module reflux.karma_conf</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.karma_conf.karma_conf" id="apidoc.element.reflux.karma_conf.karma_conf">
        function <span class="apidocSignatureSpan">reflux.</span>karma_conf
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">karma_conf = function (config) {
    config.set({
        logLevel: 'LOG_DEBUG',

        reporters: ['spec'],

        singleRun : true,
        autoWatch : false,

        frameworks: [
            'mocha',
            'browserify'
        ],

        files: [
            'test/shims/phantomjs-shims.js',
            'test/*.spec.js'
        ],

        preprocessors: {
            'test/shims/phantomjs-shims.js': ['browserify'],
            'test/*.spec.js': ['browserify']
        },

        browserify: {
            debug: true
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.listenTo" id="apidoc.module.reflux.listenTo">module reflux.listenTo</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.listenTo.listenTo" id="apidoc.element.reflux.listenTo.listenTo">
        function <span class="apidocSignatureSpan">reflux.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenTo = function (listenable, callback, initial){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenTo!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenTo(listenable,callback,initial);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
class StatusStore extends Reflux.Store
{
constructor()
{
    super();
    this.state = {flag:'OFFLINE'}; // &lt;- set store's default state much like in React
    this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action
}

onStatusUpdate(status)
{
    var newFlag = status ? 'ONLINE' : 'OFFLINE';
    this.setState({flag:newFlag});
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.listenToMany" id="apidoc.module.reflux.listenToMany">module reflux.listenToMany</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.listenToMany.listenToMany" id="apidoc.element.reflux.listenToMany.listenToMany">
        function <span class="apidocSignatureSpan">reflux.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenToMany = function (listenables){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw "Can't have other property '"+m+"' when using Reflux.listenToMany!";
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenToMany(listenables);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.nextTick" id="apidoc.module.reflux.nextTick">module reflux.nextTick</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.nextTick.nextTick" id="apidoc.element.reflux.nextTick.nextTick">
        function <span class="apidocSignatureSpan">reflux.</span>nextTick
        <span class="apidocSignatureSpan">(nextTick)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(nextTick) {
    _.nextTick = nextTick;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.setEventEmitter" id="apidoc.module.reflux.setEventEmitter">module reflux.setEventEmitter</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.setEventEmitter.setEventEmitter" id="apidoc.element.reflux.setEventEmitter.setEventEmitter">
        function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setEventEmitter(ctx) {
    _.EventEmitter = ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.setGlobalState" id="apidoc.module.reflux.setGlobalState">module reflux.setGlobalState</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.setGlobalState.setGlobalState" id="apidoc.element.reflux.setGlobalState.setGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setGlobalState = function (obj) {
		for (var storeID in obj) {
			if (Reflux.stores[storeID]) {
				Reflux.stores[storeID].setState(obj[storeID]);
			} else {
				Reflux.GlobalState[storeID] = obj[storeID];
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.use" id="apidoc.module.reflux.use">module reflux.use</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.use.use" id="apidoc.element.reflux.use.use">
        function <span class="apidocSignatureSpan">reflux.</span>use
        <span class="apidocSignatureSpan">(pluginCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(pluginCb) {
    pluginCb(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils" id="apidoc.module.reflux.utils">module reflux.utils</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.callbackName" id="apidoc.element.reflux.utils.callbackName">
        function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
        <span class="apidocSignatureSpan">(string, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function callbackName(string, prefix) {
    prefix = prefix || "on";
    return prefix + exports.capitalize(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.capitalize" id="apidoc.element.reflux.utils.capitalize">
        function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.extend" id="apidoc.element.reflux.utils.extend">
        function <span class="apidocSignatureSpan">reflux.utils.</span>extend
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i &lt; length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j &lt; keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor &amp;&amp; Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.inherits" id="apidoc.element.reflux.utils.inherits">
        function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
        <span class="apidocSignatureSpan">(subClass, superClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (subClass, superClass) {
	if (typeof superClass !== "function" &amp;&amp; superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}
	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isArguments" id="apidoc.element.reflux.utils.isArguments">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArguments(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" &amp;&amp; "callee" in value &amp;&amp; typeof value.length
 === "number";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isFunction" id="apidoc.element.reflux.utils.isFunction">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(value) {
    return typeof value === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isObject" id="apidoc.element.reflux.utils.isObject">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return type === "function" || type === "object" &amp;&amp; !!obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.nextTick" id="apidoc.element.reflux.utils.nextTick">
        function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
    setTimeout(callback, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.object" id="apidoc.element.reflux.utils.object">
        function <span class="apidocSignatureSpan">reflux.utils.</span>object
        <span class="apidocSignatureSpan">(keys, vals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i &lt; keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.throwIf" id="apidoc.element.reflux.utils.throwIf">
        function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
        <span class="apidocSignatureSpan">(val, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter" id="apidoc.module.reflux.utils.EventEmitter">module reflux.utils.EventEmitter</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype" id="apidoc.module.reflux.utils.EventEmitter.prototype">module reflux.utils.EventEmitter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.addListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.addListener">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>addListener
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit" id="apidoc.element.reflux.utils.EventEmitter.prototype.emit">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &lt; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &lt; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &lt; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames" id="apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &amp;&amp; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &lt; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.off" id="apidoc.element.reflux.utils.EventEmitter.prototype.off">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.on" id="apidoc.element.reflux.utils.EventEmitter.prototype.on">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.once" id="apidoc.element.reflux.utils.EventEmitter.prototype.once">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.emit" id="apidoc.module.reflux.utils.EventEmitter.prototype.emit">module reflux.utils.EventEmitter.prototype.emit</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit.emit" id="apidoc.element.reflux.utils.EventEmitter.prototype.emit.emit">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &lt; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &lt; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &lt; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.eventNames" id="apidoc.module.reflux.utils.EventEmitter.prototype.eventNames">module reflux.utils.EventEmitter.prototype.eventNames</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames.eventNames" id="apidoc.element.reflux.utils.EventEmitter.prototype.eventNames.eventNames">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.listeners" id="apidoc.module.reflux.utils.EventEmitter.prototype.listeners">module reflux.utils.EventEmitter.prototype.listeners</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners.listeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.listeners.listeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &amp;&amp; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &lt; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.on" id="apidoc.module.reflux.utils.EventEmitter.prototype.on">module reflux.utils.EventEmitter.prototype.on</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.on.on" id="apidoc.element.reflux.utils.EventEmitter.prototype.on.on">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.once" id="apidoc.module.reflux.utils.EventEmitter.prototype.once">module reflux.utils.EventEmitter.prototype.once</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.once.once" id="apidoc.element.reflux.utils.EventEmitter.prototype.once.once">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.removeAllListeners" id="apidoc.module.reflux.utils.EventEmitter.prototype.removeAllListeners">module reflux.utils.EventEmitter.prototype.removeAllListeners</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners.removeAllListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners.removeAllListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.removeListener" id="apidoc.module.reflux.utils.EventEmitter.prototype.removeListener">module reflux.utils.EventEmitter.prototype.removeListener</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener.removeListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeListener.removeListener">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &amp;&amp; !listeners.once)
        || (context &amp;&amp; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &lt; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &amp;&amp; !listeners[i].once)
          || (context &amp;&amp; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype.setMaxListeners" id="apidoc.module.reflux.utils.EventEmitter.prototype.setMaxListeners">module reflux.utils.EventEmitter.prototype.setMaxListeners</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners.setMaxListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners.setMaxListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.callbackName" id="apidoc.module.reflux.utils.callbackName">module reflux.utils.callbackName</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.callbackName.callbackName" id="apidoc.element.reflux.utils.callbackName.callbackName">
        function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
        <span class="apidocSignatureSpan">(string, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function callbackName(string, prefix) {
    prefix = prefix || "on";
    return prefix + exports.capitalize(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.capitalize" id="apidoc.module.reflux.utils.capitalize">module reflux.utils.capitalize</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.capitalize.capitalize" id="apidoc.element.reflux.utils.capitalize.capitalize">
        function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.extend" id="apidoc.module.reflux.utils.extend">module reflux.utils.extend</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.extend.extend" id="apidoc.element.reflux.utils.extend.extend">
        function <span class="apidocSignatureSpan">reflux.utils.</span>extend
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i &lt; length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j &lt; keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor &amp;&amp; Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.inherits" id="apidoc.module.reflux.utils.inherits">module reflux.utils.inherits</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.inherits.inherits" id="apidoc.element.reflux.utils.inherits.inherits">
        function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
        <span class="apidocSignatureSpan">(subClass, superClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (subClass, superClass) {
	if (typeof superClass !== "function" &amp;&amp; superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}
	subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.isArguments" id="apidoc.module.reflux.utils.isArguments">module reflux.utils.isArguments</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.isArguments.isArguments" id="apidoc.element.reflux.utils.isArguments.isArguments">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArguments(value) {
    return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" &amp;&amp; "callee" in value &amp;&amp; typeof value.length
 === "number";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.isFunction" id="apidoc.module.reflux.utils.isFunction">module reflux.utils.isFunction</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.isFunction.isFunction" id="apidoc.element.reflux.utils.isFunction.isFunction">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(value) {
    return typeof value === "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.isObject" id="apidoc.module.reflux.utils.isObject">module reflux.utils.isObject</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.isObject.isObject" id="apidoc.element.reflux.utils.isObject.isObject">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(obj) {
    var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
    return type === "function" || type === "object" &amp;&amp; !!obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.nextTick" id="apidoc.module.reflux.utils.nextTick">module reflux.utils.nextTick</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.nextTick.nextTick" id="apidoc.element.reflux.utils.nextTick.nextTick">
        function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
    setTimeout(callback, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.object" id="apidoc.module.reflux.utils.object">module reflux.utils.object</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.object.object" id="apidoc.element.reflux.utils.object.object">
        function <span class="apidocSignatureSpan">reflux.utils.</span>object
        <span class="apidocSignatureSpan">(keys, vals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i &lt; keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.throwIf" id="apidoc.module.reflux.utils.throwIf">module reflux.utils.throwIf</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.throwIf.throwIf" id="apidoc.element.reflux.utils.throwIf.throwIf">
        function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
        <span class="apidocSignatureSpan">(val, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>