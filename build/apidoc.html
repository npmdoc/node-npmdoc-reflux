<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/reflux/refluxjs#readme"

    >reflux (v6.4.1)</a>
</h1>
<h4>A simple library for uni-directional dataflow application architecture inspired by ReactJS Flux</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux">module reflux</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.</span>serverMode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component">
            function <span class="apidocSignatureSpan">reflux.</span>Component
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store">
            function <span class="apidocSignatureSpan">reflux.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.all">
            function <span class="apidocSignatureSpan">reflux.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connect">
            function <span class="apidocSignatureSpan">reflux.</span>connect
            <span class="apidocSignatureSpan">(listenable, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.connectFilter">
            function <span class="apidocSignatureSpan">reflux.</span>connectFilter
            <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createAction">
            function <span class="apidocSignatureSpan">reflux.</span>createAction
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createActions">
            function <span class="apidocSignatureSpan">reflux.</span>createActions
            <span class="apidocSignatureSpan">(definitions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.createStore">
            function <span class="apidocSignatureSpan">reflux.</span>createStore
            <span class="apidocSignatureSpan">(definition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.defineReact">
            function <span class="apidocSignatureSpan">reflux.</span>defineReact
            <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.getGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.initStore">
            function <span class="apidocSignatureSpan">reflux.</span>initStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.initializeGlobalStore">
            function <span class="apidocSignatureSpan">reflux.</span>initializeGlobalStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinConcat">
            function <span class="apidocSignatureSpan">reflux.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinLeading">
            function <span class="apidocSignatureSpan">reflux.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinStrict">
            function <span class="apidocSignatureSpan">reflux.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenTo">
            function <span class="apidocSignatureSpan">reflux.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.listenToMany">
            function <span class="apidocSignatureSpan">reflux.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.nextTick">
            function <span class="apidocSignatureSpan">reflux.</span>nextTick
            <span class="apidocSignatureSpan">(nextTick)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setEventEmitter">
            function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.setGlobalState">
            function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.use">
            function <span class="apidocSignatureSpan">reflux.</span>use
            <span class="apidocSignatureSpan">(pluginCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ActionMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>Component.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>GlobalState</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ListenerMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>ListenerMixin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>PublisherMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>PureComponent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>Store.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>StoreMethods</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>__keep</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>stores</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component">module reflux.Component</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.Component">
            function <span class="apidocSignatureSpan">reflux.</span>Component
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.extend">
            function <span class="apidocSignatureSpan">reflux.Component.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Component.prototype">module reflux.Component.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Component.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.Component.prototype.</span>storeKeys</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMethods">module reflux.ListenerMethods</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.hasListener">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinConcat">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinLeading">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinStrict">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.listenToMany">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMethods.validateListening">
            function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.ListenerMixin">module reflux.ListenerMixin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.fetchInitialState">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>fetchInitialState
            <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.hasListener">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>hasListener
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinConcat">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinLeading">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinLeading
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinStrict">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinStrict
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.joinTrailing">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinTrailing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.listenTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenTo
            <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.listenToMany">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenToMany
            <span class="apidocSignatureSpan">(listenables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.stopListeningTo">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningTo
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.stopListeningToAll">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningToAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.ListenerMixin.validateListening">
            function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>validateListening
            <span class="apidocSignatureSpan">(listenable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PublisherMethods">module reflux.PublisherMethods</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.deferWith">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.listen">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
            <span class="apidocSignatureSpan">(callback, bindContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.preEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.shouldEmit">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.trigger">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PublisherMethods.triggerAsync">
            function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent">module reflux.PureComponent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.PureComponent">
            function <span class="apidocSignatureSpan">reflux.</span>PureComponent
            <span class="apidocSignatureSpan">(props, context, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.extend">
            function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
            <span class="apidocSignatureSpan">(clss)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.PureComponent.prototype">module reflux.PureComponent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
            function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
            <span class="apidocSignatureSpan">(store, filterFunc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>storeKeys</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Store">module reflux.Store</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.Store.</span>isES6Store</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.Store">
            function <span class="apidocSignatureSpan">reflux.</span>Store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.Store.prototype">module reflux.Store.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.Store.prototype.setState">
            function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.__keep">module reflux.__keep</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addAction">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
            <span class="apidocSignatureSpan">(act)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.addStore">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.reset">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.__keep.useKeep">
            function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.__keep.</span>createdActions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">reflux.__keep.</span>createdStores</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils">module reflux.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.callbackName">
            function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
            <span class="apidocSignatureSpan">(string, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.capitalize">
            function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.extend">
            function <span class="apidocSignatureSpan">reflux.utils.</span>extend
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.inherits">
            function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
            <span class="apidocSignatureSpan">(subClass, superClass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isArguments">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isFunction">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.isObject">
            function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.nextTick">
            function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.object">
            function <span class="apidocSignatureSpan">reflux.utils.</span>object
            <span class="apidocSignatureSpan">(keys, vals)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.throwIf">
            function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
            <span class="apidocSignatureSpan">(val, msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter">module reflux.utils.EventEmitter</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">reflux.utils.EventEmitter.</span>prefixed</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.EventEmitter">
            function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.reflux.utils.EventEmitter.prototype">module reflux.utils.EventEmitter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.addListener">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>addListener
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
            <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
            <span class="apidocSignatureSpan">(event, exists)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.off">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.on">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.once">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(event, fn, context, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux" id="apidoc.module.reflux">module reflux</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.Component" id="apidoc.element.reflux.Component">
        function <span class="apidocSignatureSpan">reflux.</span>Component
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent" id="apidoc.element.reflux.PureComponent">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Store" id="apidoc.element.reflux.Store">
        function <span class="apidocSignatureSpan">reflux.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store = function () {
		// extending doesn&#x27;t really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.all" id="apidoc.element.reflux.all">
        function <span class="apidocSignatureSpan">reflux.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat(&#x22;triggerAsync&#x22;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.connect" id="apidoc.element.reflux.connect">
        function <span class="apidocSignatureSpan">reflux.</span>connect
        <span class="apidocSignatureSpan">(listenable, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (listenable, key) {

    _.throwIf(typeof(key) === &#x27;undefined&#x27;, &#x27;Reflux.connect() requires a key.&#x27;);

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            return _.object([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
            var me = this;

            _.extend(me, ListenerMethods);

            this.listenTo(listenable, function(v) {
                me.setState(_.object([key],[v]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can have multiple calls to `Reflux.listenTo` in the same `mixins` array.

There is also `Reflux.listenToMany` which works in exactly the same way, exposing `listener.listenToMany`.

#### Using Reflux.connect

If all you want to do is update the state of your component to whatever the data store transmits, you can use `Reflux.<span class
="apidocCodeKeywordSpan">connect</span>(listener,stateKey)` as a mixin. The state is updated via `this.setState({&#x3c;stateKey&#
x3e;:data})`. Here&#x27;s the example above changed to use this syntax:

```javascript
var Status = React.createClass({
mixins: [Reflux.connect(statusStore,&#x22;currentStatus&#x22;)],
render: function() {
    // render using `this.state.currentStatus`
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.connectFilter" id="apidoc.element.reflux.connectFilter">
        function <span class="apidocSignatureSpan">reflux.</span>connectFilter
        <span class="apidocSignatureSpan">(listenable, key, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectFilter = function (listenable, key, filterFunc) {

    _.throwIf(_.isFunction(key), &#x27;Reflux.connectFilter() requires a key.&#x27;);

    return {
        getInitialState: function() {
            if (!_.isFunction(listenable.getInitialState)) {
                return {};
            }

            // Filter initial payload from store.
            var result = filterFunc.call(this, listenable.getInitialState());
            if (typeof(result) !== &#x27;undefined&#x27;) {
                return _.object([key], [result]);
            } else {
                return {};
            }
        },
        componentDidMount: function() {
            var me = this;

            _.extend(this, ListenerMethods);

            this.listenTo(listenable, function(value) {
                var result = filterFunc.call(me, value);
                me.setState(_.object([key], [result]));
            });
        },
        componentWillUnmount: ListenerMixin.componentWillUnmount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`connectFilter` mixin when you want only a subset of the items in a store. A
blog written using Reflux would probably have a store with all posts in
it. For an individual post page, you could use `Reflux.connectFilter` to
filter the posts to the post that&#x27;s being viewed.

```javascript
var PostView = React.createClass({
mixins: [Reflux.<span class="apidocCodeKeywordSpan">connectFilter</span>(postStore, &#x22;post&#x22;, function(posts) {
    return posts.filter(function(post) {
       return post.id === this.props.id;
    }.bind(this))[0];
})],
render: function() {
    // render using `this.state.post`
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createAction" id="apidoc.element.reflux.createAction">
        function <span class="apidocSignatureSpan">reflux.</span>createAction
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createAction(definition) {

    definition = definition || {};
    if (!_.isObject(definition)) {
        definition = { actionName: definition };
    }

    for (var a in ActionMethods) {
        if (!allowed[a] &#x26;&#x26; PublisherMethods[a]) {
            throw new Error(&#x22;Cannot override API method &#x22; + a + &#x22; in Reflux.ActionMethods. Use another method name or override it
 on Reflux.PublisherMethods instead.&#x22;);
        }
    }

    for (var d in definition) {
        if (!allowed[d] &#x26;&#x26; PublisherMethods[d]) {
            throw new Error(&#x22;Cannot override API method &#x22; + d + &#x22; in action creation. Use another method name or override it on
Reflux.PublisherMethods instead.&#x22;);
        }
    }

    definition.children = definition.children || [];
    if (definition.asyncResult) {
        definition.children = definition.children.concat([&#x22;completed&#x22;, &#x22;failed&#x22;]);
    }

    var i = 0,
        childActions = {};
    for (; i &#x3c; definition.children.length; i++) {
        var chDef = definition.children[i];
        var chName = typeof chDef === &#x22;string&#x22; ? chDef : chDef.actionName;
        childActions[chName] = createAction(chDef);
    }

    var context = _.extend({
        eventLabel: &#x22;action&#x22;,
        emitter: new _.EventEmitter(),
        _isAction: true
    }, PublisherMethods, ActionMethods, definition);

    var functor = function functor() {
        var hasChildActions = false;
<span class="apidocCodeCommentSpan">        /* eslint no-unused-vars:0 */
</span>        for (var ignore in functor.childActions) {
            hasChildActions = true;break;
        }
        var async = !functor.sync &#x26;&#x26; typeof functor.sync !== &#x22;undefined&#x22; || hasChildActions;
        var triggerType = async ? &#x22;triggerAsync&#x22; : &#x22;trigger&#x22;;
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.addAction(functor);

    return functor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Usage

### Creating actions

Create an action by calling `Reflux.createAction` with an optional options object.

```javascript
var statusUpdate = Reflux.<span class="apidocCodeKeywordSpan">createAction</span>(options);
```

An action is a [function object](http://en.wikipedia.org/wiki/Function_object) that can be invoked like any function.

```javascript
statusUpdate(data); // Invokes the action statusUpdate
statusUpdate.triggerAsync(data); // same effect as above
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createActions" id="apidoc.element.reflux.createActions">
        function <span class="apidocSignatureSpan">reflux.</span>createActions
        <span class="apidocSignatureSpan">(definitions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createActions = function (definitions) {
    var actions = {};
    if (definitions instanceof Array) {
        definitions.forEach(function (val) {
            if (_.isObject(val)) {
                reducer(val, actions);
            } else {
                actions[val] = (0, _createAction.createAction)(val);
            }
        });
    } else {
        reducer(definitions, actions);
    }
    return actions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

If `options.sync` is true, the functor will instead call `action.trigger` which is a synchronous operation. You can change `action
.sync` during the lifetime of the action, and the following calls will honour that change.

There is also a convenience function for creating multiple actions.

```javascript
var Actions = Reflux.<span class="apidocCodeKeywordSpan">createActions</span>([
    &#x22;statusUpdate&#x22;,
    &#x22;statusEdited&#x22;,
    &#x22;statusAdded&#x22;
  ]);

// Actions object now contains the actions
// with the names given in the array above
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.createStore" id="apidoc.element.reflux.createStore">
        function <span class="apidocSignatureSpan">reflux.</span>createStore
        <span class="apidocSignatureSpan">(definition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStore(definition) {

    definition = definition || {};

    for (var a in StoreMethods) {
        if (!allowed[a] &#x26;&#x26; (PublisherMethods[a] || ListenerMethods[a])) {
            throw new Error(&#x22;Cannot override API method &#x22; + a + &#x22; in Reflux.StoreMethods. Use another method name or override it
 on Reflux.PublisherMethods / Reflux.ListenerMethods instead.&#x22;);
        }
    }

    for (var d in definition) {
        if (!allowed[d] &#x26;&#x26; (PublisherMethods[d] || ListenerMethods[d])) {
            throw new Error(&#x22;Cannot override API method &#x22; + d + &#x22; in store creation. Use another method name or override it on Reflux
.PublisherMethods / Reflux.ListenerMethods instead.&#x22;);
        }
    }

    definition = (0, _mixer.mix)(definition);

    function Store() {
        var i = 0,
            arr;
        this.subscriptions = [];
        this.emitter = new _.EventEmitter();
        this.eventLabel = &#x22;change&#x22;;
        (0, _bindMethods.bindMethods)(this, definition);
        if (this.init &#x26;&#x26; _.isFunction(this.init)) {
            this.init();
        }
        if (this.listenables) {
            arr = [].concat(this.listenables);
            for (; i &#x3c; arr.length; i++) {
                this.listenToMany(arr[i]);
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.addStore(store);

    return store;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Creating data stores

Create a data store much like ReactJS&#x27;s own `React.createClass` by passing a definition object to `Reflux.createStore`. You
 may set up all action listeners in the `init` function and register them by calling the store&#x27;s own `listenTo` function.

```javascript
// Creates a DataStore
var statusStore = Reflux.<span class="apidocCodeKeywordSpan">createStore</span>({

// Initial setup
init: function() {

    // Register statusUpdate action
    this.listenTo(statusUpdate, this.output);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.defineReact" id="apidoc.element.reflux.defineReact">
        function <span class="apidocSignatureSpan">reflux.</span>defineReact
        <span class="apidocSignatureSpan">(react, noLongerUsed, extend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineReact(react, noLongerUsed, extend)
{
	var proto, _extend;
	
	// if no Reflux object is yet available then return and just wait until defineReact is called manually with it
	try {
		_react  = react  || _react  || React;
		_extend = extend || _react.Component;
	} catch (e) {
		return;
	}
	
	// if Reflux and React aren&#x27;t present then ignore, wait until they are properly present
	// also ignore if it&#x27;s been called before UNLESS there&#x27;s manual extending happening
	if (!_react || !_extend || (_defined &#x26;&#x26; !extend)) {
		return;
	}
	
	// ----------- BEGIN Reflux.Component ------------
	/**
	 * Reflux.Component:
	 * An implementation for idiomatic React.js classes that mix with
	 * Reflux stores. To utilize extend Reflux.Component instead of
	 * React.Component. Then you may hook any Reflux store that has a
	 * `this.state` property containing its state values to the component
	 * via `this.store` or an Array of Reflux stores via `this.stores` in
	 * the component&#x27;s constructor (similar to how you assign initial state
	 * in the constructor in ES6 style React). The default values of the
	 * stores will automatically reflect in the component&#x27;s state, and any
	 * further `trigger` calls from that store will update properties passed
	 * in the trigger into the component automatically.
	 */
	var RefluxComponent = function(props, context, updater) {
		_extend.call(this, props, context, updater);
	};
	
	// equivalent of `extends React.Component` or other class if provided via `extend` param
	Reflux.utils.inherits(RefluxComponent, _extend);
	
	proto = RefluxComponent.prototype;
	
	/**
	 * this.storeKeys
	 * When this is a falsey value (null by default) the component mixes in
	 * all properties from the stores attached to it and updates on changes
	 * from all of them. When set to an array of string keys it will only
	 * utilized state property names of those keys in any store attached. This
	 * lets you choose which parts of stores update the component on a component-
	 * by-component basis. If using this it is best set in the constructor.
	 */
	proto.storeKeys = null;
	
	// on the mounting of the component that is where the store/stores are attached and initialized if needed
	proto.componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what&#x27;s updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &#x3c; ii; i++) {
				var str = this.stores[i];
				// if&#x27;s a function then we know it&#x27;s a class getting passed, not an instance
				if (typeof str === &#x27;function&#x27;) {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren&#x27;t sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it&#x27;s the instance we&#x27;re working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Reflux.Component` extends `React.Component`. Therefore Reflux needs to be able to access React in order to expose it. In the browser
 as long as React is loaded before Reflux then Reflux will automatically find it. Likewise in node-like environments where `require
(&#x27;react&#x27;)` will function Reflux will try to access React that way. So in almost all situations Reflux will find React
on its own.

However, Reflux also exposes the method `Reflux.defineReact` that you can use to manually give Reflux a reference to the React object
 in case you need to:

```javascript
// only needed if, for some reason, Reflux can&#x27;t get reference to React:
var React = /* however you access React */;
Reflux.<span class="apidocCodeKeywordSpan">defineReact</span>(React);
// now Reflux.Component is accessible!
```

### Extending a 3rd Party Class

Sometimes 3rd party libraries will have their own class that extends `React.Component` that they require you to use. Reflux handles
 this by exposing the `Reflux.Component.extend` method. If you have such a 3rd party class you can pass that class to this method
 and it will return a version of `Reflux.Component` that extends it instead of extending `React.Component` directly. Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.getGlobalState" id="apidoc.element.reflux.getGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>getGlobalState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getGlobalState = function () {
		return clone(Reflux.GlobalState);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// at this point it would render with a count of 50!
```

One of the most useful ways you could do this is to store a `Reflux.GlobalState` state as a JSON string in order to implement it
 again the next time the app starts up and have the user begin right where they left off.

#### Reflux.setGlobalState and Reflux.getGlobalState

Directly accessing `Reflux.GlobalState` is a fine way to do set the starting state of an app and to do automated testing, but it
 is also helpful to be able to manipulate the global state while the app is running as well. To do this Reflux exposes a `Reflux
.<span class="apidocCodeKeywordSpan">getGlobalState</span>()` function and a `Reflux.setGlobalState()` function. The former allows
 you to get a deep copy of the current global state (so that the copy will not mutate as the global state itself continues to mutate
) and the latter allows you to set part or all of the global state at any time in the program. Between these two functions things
 like state time-travel, undo/redo, and move-by-move tracking become relatively easy.

### Making sure Reflux.Component is available

`Reflux.Component` extends `React.Component`. Therefore Reflux needs to be able to access React in order to expose it. In the browser
 as long as React is loaded before Reflux then Reflux will automatically find it. Likewise in node-like environments where `require
(&#x27;react&#x27;)` will function Reflux will try to access React that way. So in almost all situations Reflux will find React
on its own.

However, Reflux also exposes the method `Reflux.defineReact` that you can use to manually give Reflux a reference to the React object
 in case you need to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.initStore" id="apidoc.element.reflux.initStore">
        function <span class="apidocSignatureSpan">reflux.</span>initStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initStore = function (str) {
		var storeId = str.id;
		// if they&#x27;re initializing something twice then we&#x27;re done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it&#x27;s easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class&#x27;s singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	proto.mapStoreToState = function(store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === &#x27;function&#x27;) {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.<span class="apidocCodeKeywordSpan">initStore</span>(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.initializeGlobalStore" id="apidoc.element.reflux.initializeGlobalStore">
        function <span class="apidocSignatureSpan">reflux.</span>initializeGlobalStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeGlobalStore = function (str) {
		var storeId = str.id;
		// if they&#x27;re initializing something twice then we&#x27;re done already, return it
		if (str.singleton) {
			return str.singleton;
		}
		// if no id then it&#x27;s easy: just make new instance and set to singleton
		if (!storeId) {
			str.singleton = new str();
			return str.singleton;
		}
		// create the singleton and assign it to the class&#x27;s singleton static property
		var inst = str.singleton = new str();
		// store it on the Reflux.stores array to be accessible later
		Reflux.stores[storeId] = inst;
		// the singleton instance itself should also have the id property of the class
		inst.id = storeId;
		// if the global state has something set for this id, copy it to the state and then
		// make sure to set the global state to the end result, since it may have only been partial
		if (Reflux.GlobalState[storeId]) {
			for (var key in Reflux.GlobalState[storeId]) {
				inst.state[key] = Reflux.GlobalState[storeId][key];
			}
			Reflux.GlobalState[storeId] = inst.state;
		// otherwise just set the global state to the default state of the class
		} else {
			Reflux.GlobalState[storeId] = inst.state;
		}
		// returns the singleton itself, though it will also be accessible as as `MyClass.singleton`
		return inst;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Note!** `Reflux.Store` still works with instances of stores (i.e. the class must get intantiated). Assigning the class itself
to `this.store` just allows Reflux to handle the instantiation and do some internal things that allow features like global state
 tracking. it does *not* mean that the class itself is the store. Internally Reflux creates and utilizes a singleton instance of
 the class. After mounting you may access that singleton instance of the class via `MyStoreClass.singleton`.

#### Using Reflux.Store without a component

With to ability to do so much via global states (covered in the next section), and the fact that that functionality is tied to `
Reflux.Store`, being able to properly utilize `Reflux.Store` on its own (without binding to a React component) becomes useful. However
, just using `new MyStoreClass()` isn&#x27;t enough, as it has to tie itself into the Reflux global state as a singleton. Therefore
 Reflux exposes an API for getting a properly globalized singleton instance of a `Reflux.Store` extended class without having to
 tie it to a React component. You do this via the following:

```javascript
var mySingleton = Reflux.<span class="apidocCodeKeywordSpan">initializeGlobalStore</span>(MyClassName);
```

When done this way the singleton instance of your `Reflux.Store` class can, externally, be used much like a non-ES6 store created
 via `Reflux.createStore` except with the advantages that it: 1) is written in the `Reflux.Store` ES6 syntax and 2) it ties in with
 the global state being tracked by Reflux.

Note: your store _must_ be set up with an `id` to be used this way.

Note: even after instantiating with `Reflux.initializeGlobalStore` you can still later assign the class name itself to `this.store
` or `this.stores` in a `Reflux.Component`. The component will recognize that a singleton for the class has already been created
 and use that singleton.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinConcat" id="apidoc.element.reflux.joinConcat">
        function <span class="apidocSignatureSpan">reflux.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat(&#x22;triggerAsync&#x22;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinLeading" id="apidoc.element.reflux.joinLeading">
        function <span class="apidocSignatureSpan">reflux.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat(&#x22;triggerAsync&#x22;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinStrict" id="apidoc.element.reflux.joinStrict">
        function <span class="apidocSignatureSpan">reflux.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat(&#x22;triggerAsync&#x22;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.joinTrailing" id="apidoc.element.reflux.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables... */{
    var listenables = slice.call(arguments);
    return (0, _createStore.createStore)({
        init: function init() {
            this[strategyMethodNames[strategy]].apply(this, listenables.concat(&#x22;triggerAsync&#x22;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Using the listener instance methods

All objects using the listener API (stores, React components using `ListenerMixin`, or other components using the `ListenerMethods
`) gain access to the four join instance methods, named after the argument strategy. Here&#x27;s an example saving the last emission
 from each publisher:

```javascript
var gainHeroBadgeStore = Reflux.createStore({
    init: function() {
        this.<span class="apidocCodeKeywordSpan">joinTrailing</span>(actions.disarmBomb, actions.saveHostage, actions.recoverData
, this.triggerAsync);
    }
});

actions.disarmBomb(&#x22;warehouse&#x22;);
actions.recoverData(&#x22;seedyletter&#x22;);
actions.disarmBomb(&#x22;docks&#x22;);
actions.saveHostage(&#x22;offices&#x22;,3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.listenTo" id="apidoc.element.reflux.listenTo">
        function <span class="apidocSignatureSpan">reflux.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenTo = function (listenable, callback, initial){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw &#x22;Can&#x27;t have other property &#x27;&#x22;+m+&#x22;&#x27; when using Reflux.listenTo!&#x22;;
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenTo(listenable,callback,initial);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Creates a DataStore
var statusStore = Reflux.createStore({

    // Initial setup
    init: function() {

// Register statusUpdate action
this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.output);
    },

    // Callback
    output: function(flag) {
var status = flag ? &#x27;ONLINE&#x27; : &#x27;OFFLINE&#x27;;

// Pass on to listeners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.listenToMany" id="apidoc.element.reflux.listenToMany">
        function <span class="apidocSignatureSpan">reflux.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenToMany = function (listenables){
    return {
        /**
         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
         * and then make the call to `listenTo` with the arguments provided to the factory function
         */
        componentDidMount: function() {
            for(var m in ListenerMethods){
                if (this[m] !== ListenerMethods[m]){
                    if (this[m]){
                        throw &#x22;Can&#x27;t have other property &#x27;&#x22;+m+&#x22;&#x27; when using Reflux.listenToMany!&#x22;;
                    }
                    this[m] = ListenerMethods[m];
                }
            }
            this.listenToMany(listenables);
        },
        /**
         * Cleans up all listener previously registered.
         */
        componentWillUnmount: ListenerMethods.stopListeningToAll
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
...you can do this:

```javascript
var actions = Reflux.createActions([&#x22;fireBall&#x22;,&#x22;magicMissile&#x22;]);

var Store = Reflux.createStore({
init: function() {
    this.<span class="apidocCodeKeywordSpan">listenToMany</span>(actions);
},
onFireBall: function(){
    // whoooosh!
},
onMagicMissile: function(){
    // bzzzzapp!
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.nextTick" id="apidoc.element.reflux.nextTick">
        function <span class="apidocSignatureSpan">reflux.</span>nextTick
        <span class="apidocSignatureSpan">(nextTick)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(nextTick) {
    _.nextTick = nextTick;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Whenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.

You may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:

```javascript

// node.js env
Reflux.<span class="apidocCodeKeywordSpan">nextTick</span>(process.nextTick);
```

For better alternative to `setTimeout`, you may opt to use the [`setImmediate` polyfill](https://github.com/YuzuJS/setImmediate), [`
setImmediate2`](https://github.com/Katochimoto/setImmediate) or [`macrotask`](https://github.com/calvinmetcalf/macrotask).


### Joining parallel listeners with composed listenables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.setEventEmitter" id="apidoc.element.reflux.setEventEmitter">
        function <span class="apidocSignatureSpan">reflux.</span>setEventEmitter
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setEventEmitter(ctx) {
    _.EventEmitter = ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Switching EventEmitter

Don&#x27;t like to use the EventEmitter provided? You can switch to another one, such as NodeJS&#x27;s own like this:

```javascript
// Do this before creating actions or stores

Reflux.<span class="apidocCodeKeywordSpan">setEventEmitter</span>(require(&#x27;events&#x27;).EventEmitter);
```

### Switching nextTick

Whenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.

You may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.setGlobalState" id="apidoc.element.reflux.setGlobalState">
        function <span class="apidocSignatureSpan">reflux.</span>setGlobalState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setGlobalState = function (obj) {
		for (var storeID in obj) {
			if (Reflux.stores[storeID]) {
				Reflux.stores[storeID].setState(obj[storeID]);
			} else {
				Reflux.GlobalState[storeID] = obj[storeID];
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// at this point it would render with a count of 50!
```

One of the most useful ways you could do this is to store a `Reflux.GlobalState` state as a JSON string in order to implement it
 again the next time the app starts up and have the user begin right where they left off.

#### Reflux.setGlobalState and Reflux.getGlobalState

Directly accessing `Reflux.GlobalState` is a fine way to do set the starting state of an app and to do automated testing, but it
 is also helpful to be able to manipulate the global state while the app is running as well. To do this Reflux exposes a `Reflux
.getGlobalState()` function and a `Reflux.<span class="apidocCodeKeywordSpan">setGlobalState</span>()` function. The former allows
 you to get a deep copy of the current global state (so that the copy will not mutate as the global state itself continues to mutate
) and the latter allows you to set part or all of the global state at any time in the program. Between these two functions things
 like state time-travel, undo/redo, and move-by-move tracking become relatively easy.

### Making sure Reflux.Component is available

`Reflux.Component` extends `React.Component`. Therefore Reflux needs to be able to access React in order to expose it. In the browser
 as long as React is loaded before Reflux then Reflux will automatically find it. Likewise in node-like environments where `require
(&#x27;react&#x27;)` will function Reflux will try to access React that way. So in almost all situations Reflux will find React
on its own.

However, Reflux also exposes the method `Reflux.defineReact` that you can use to manually give Reflux a reference to the React object
 in case you need to:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.use" id="apidoc.element.reflux.use">
        function <span class="apidocSignatureSpan">reflux.</span>use
        <span class="apidocSignatureSpan">(pluginCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(pluginCb) {
    pluginCb(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.</span>utils.EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component" id="apidoc.module.reflux.Component">module reflux.Component</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.Component" id="apidoc.element.reflux.Component.Component">
        function <span class="apidocSignatureSpan">reflux.</span>Component
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Component = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.extend" id="apidoc.element.reflux.Component.extend">
        function <span class="apidocSignatureSpan">reflux.Component.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Extending a 3rd Party Class

Sometimes 3rd party libraries will have their own class that extends `React.Component` that they require you to use. Reflux handles
 this by exposing the `Reflux.Component.extend` method. If you have such a 3rd party class you can pass that class to this method
 and it will return a version of `Reflux.Component` that extends it instead of extending `React.Component` directly. Example:

```javascript
import {ThirdPartyComponent} from &#x27;third-party&#x27;;

var RefluxThirdPartyComponent = Reflux.Component.<span class="apidocCodeKeywordSpan">extend</span>(ThirdPartyComponent);

class MyComponent extends RefluxThirdPartyComponent
{
    // ...
}
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Component.prototype" id="apidoc.module.reflux.Component.prototype">module reflux.Component.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillMount" id="apidoc.element.reflux.Component.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what&#x27;s updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &#x3c; ii; i++) {
				var str = this.stores[i];
				// if&#x27;s a function then we know it&#x27;s a class getting passed, not an instance
				if (typeof str === &#x27;function&#x27;) {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren&#x27;t sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it&#x27;s the instance we&#x27;re working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &#x26;&#x26; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the &#x22;.trigger()&#x22; in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&#x3c;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
	// ...
	
	componentWillMount()
	{
		// ... your stuff ...
		
		super.<span class="apidocCodeKeywordSpan">componentWillMount</span>();
	}
	
	//...
```

### More:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.componentWillUnmount" id="apidoc.element.reflux.Component.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &#x3c; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.Component.prototype.mapStoreToState" id="apidoc.element.reflux.Component.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.Component.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === &#x27;function&#x27;) {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This method takes 2 arguments: the `Reflux.Store` you want mapped to the component state (either the class itself or the singleton
 instance) and a mapping function supplied by you. The mapping function will be called any time the store instance&#x27;s `setState
` is used to change the state of the store. The mapping function takes an argument which will be the state change object from the
 store for that particular change. It needs to return an object which will then be mapped to the component state (similar to if
that very returned object were used in the component&#x27;s `setState`). If an object with no properties is returned then the component
 will *not* re-render. The mapping function is also called with its `this` keyword representing the component, so comparing store
 values to current component state values via `this.state` is possible as well.

```javascript
class Counter extends Reflux.Component
{
constructor(props) {
    super(props);
    this.<span class="apidocCodeKeywordSpan">mapStoreToState</span>(MyStoreClass, function(fromStore){
        var obj = {};
        if (fromStore.color)
            obj.color = fromStore.color;
        if (fromStore.data &#x26;&#x26; fromStore.data.classToUse)
            obj.class = fromStore.data.classToUse;
        return obj;
    });
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMethods" id="apidoc.module.reflux.ListenerMethods">module reflux.ListenerMethods</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.fetchInitialState" id="apidoc.element.reflux.ListenerMethods.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &#x26;&#x26; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &#x26;&#x26; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &#x26;&#x26; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
var desub,
    unsubscriber,
    subscriptionobj,
    subs = this.subscriptions = this.subscriptions || [];
_.throwIf(this.validateListening(listenable));
this.<span class="apidocCodeKeywordSpan">fetchInitialState</span>(listenable, defaultCallback);
desub = listenable.listen(this[callback] || callback, this);
unsubscriber = function unsubscriber() {
    var index = subs.indexOf(subscriptionobj);
    _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
    subs.splice(index, 1);
    desub();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.hasListener" id="apidoc.element.reflux.ListenerMethods.hasListener">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &#x3c; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &#x3c; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &#x26;&#x26; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        j,
        listener,
        listenables;
    for (; i &#x3c; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &#x3c; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &#x26;&#x26; listener.<span class="apidocCodeKeywordSpan">hasListener
</span>(listenable)) {
                return true;
            }
        }
    }
    return false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinConcat" id="apidoc.element.reflux.ListenerMethods.joinConcat">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinLeading" id="apidoc.element.reflux.ListenerMethods.joinLeading">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinStrict" id="apidoc.element.reflux.ListenerMethods.joinStrict">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.joinTrailing" id="apidoc.element.reflux.ListenerMethods.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Using the listener instance methods

All objects using the listener API (stores, React components using `ListenerMixin`, or other components using the `ListenerMethods
`) gain access to the four join instance methods, named after the argument strategy. Here&#x27;s an example saving the last emission
 from each publisher:

```javascript
var gainHeroBadgeStore = Reflux.createStore({
    init: function() {
        this.<span class="apidocCodeKeywordSpan">joinTrailing</span>(actions.disarmBomb, actions.saveHostage, actions.recoverData
, this.triggerAsync);
    }
});

actions.disarmBomb(&#x22;warehouse&#x22;);
actions.recoverData(&#x22;seedyletter&#x22;);
actions.disarmBomb(&#x22;docks&#x22;);
actions.saveHostage(&#x22;offices&#x22;,3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenTo" id="apidoc.element.reflux.ListenerMethods.listenTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Creates a DataStore
var statusStore = Reflux.createStore({

    // Initial setup
    init: function() {

// Register statusUpdate action
this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.output);
    },

    // Callback
    output: function(flag) {
var status = flag ? &#x27;ONLINE&#x27; : &#x27;OFFLINE&#x27;;

// Pass on to listeners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.listenToMany" id="apidoc.element.reflux.ListenerMethods.listenToMany">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + &#x22;Default&#x22;] || this[localname + &#x22;Default&#x22;] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
...you can do this:

```javascript
var actions = Reflux.createActions([&#x22;fireBall&#x22;,&#x22;magicMissile&#x22;]);

var Store = Reflux.createStore({
init: function() {
    this.<span class="apidocCodeKeywordSpan">listenToMany</span>(actions);
},
onFireBall: function(){
    // whoooosh!
},
onMagicMissile: function(){
    // bzzzzapp!
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningTo" id="apidoc.element.reflux.ListenerMethods.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &#x3c; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, &#x22;Failed to remove listen from subscriptions list!&#x22;);
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.stopListeningToAll" id="apidoc.element.reflux.ListenerMethods.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, &#x22;Failed to remove listen from subscriptions list!&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMethods.validateListening" id="apidoc.element.reflux.ListenerMethods.validateListening">
        function <span class="apidocSignatureSpan">reflux.ListenerMethods.</span>validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return &#x22;Listener is not able to listen to itself&#x22;;
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + &#x22; is missing a listen method&#x22;;
    }
    if (listenable.hasListener &#x26;&#x26; listenable.hasListener(this)) {
        return &#x22;Listener cannot listen to this listenable because of circular loop&#x22;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
var desub,
    unsubscriber,
    subscriptionobj,
    subs = this.subscriptions = this.subscriptions || [];
_.throwIf(this.<span class="apidocCodeKeywordSpan">validateListening</span>(listenable));
this.fetchInitialState(listenable, defaultCallback);
desub = listenable.listen(this[callback] || callback, this);
unsubscriber = function unsubscriber() {
    var index = subs.indexOf(subscriptionobj);
    _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
    subs.splice(index, 1);
    desub();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.ListenerMixin" id="apidoc.module.reflux.ListenerMixin">module reflux.ListenerMixin</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.componentWillUnmount" id="apidoc.element.reflux.ListenerMixin.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, &#x22;Failed to remove listen from subscriptions list!&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.fetchInitialState" id="apidoc.element.reflux.ListenerMixin.fetchInitialState">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>fetchInitialState
        <span class="apidocSignatureSpan">(listenable, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchInitialState(listenable, defaultCallback) {
    defaultCallback = defaultCallback &#x26;&#x26; this[defaultCallback] || defaultCallback;
    var me = this;
    if (_.isFunction(defaultCallback) &#x26;&#x26; _.isFunction(listenable.getInitialState)) {
        var data = listenable.getInitialState();
        if (data &#x26;&#x26; _.isFunction(data.then)) {
            data.then(function () {
                defaultCallback.apply(me, arguments);
            });
        } else {
            defaultCallback.call(this, data);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
var desub,
    unsubscriber,
    subscriptionobj,
    subs = this.subscriptions = this.subscriptions || [];
_.throwIf(this.validateListening(listenable));
this.<span class="apidocCodeKeywordSpan">fetchInitialState</span>(listenable, defaultCallback);
desub = listenable.listen(this[callback] || callback, this);
unsubscriber = function unsubscriber() {
    var index = subs.indexOf(subscriptionobj);
    _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
    subs.splice(index, 1);
    desub();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.hasListener" id="apidoc.element.reflux.ListenerMixin.hasListener">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>hasListener
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasListener(listenable) {
    var i = 0,
        j,
        listener,
        listenables;
    for (; i &#x3c; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &#x3c; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &#x26;&#x26; listener.hasListener(listenable)) {
                return true;
            }
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        j,
        listener,
        listenables;
    for (; i &#x3c; (this.subscriptions || []).length; ++i) {
        listenables = [].concat(this.subscriptions[i].listenable);
        for (j = 0; j &#x3c; listenables.length; j++) {
            listener = listenables[j];
            if (listener === listenable || listener.hasListener &#x26;&#x26; listener.<span class="apidocCodeKeywordSpan">hasListener
</span>(listenable)) {
                return true;
            }
        }
    }
    return false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinConcat" id="apidoc.element.reflux.ListenerMixin.joinConcat">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinConcat = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinLeading" id="apidoc.element.reflux.ListenerMixin.joinLeading">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinLeading
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinLeading = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinStrict" id="apidoc.element.reflux.ListenerMixin.joinStrict">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinStrict
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinStrict = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.joinTrailing" id="apidoc.element.reflux.ListenerMixin.joinTrailing">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>joinTrailing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinTrailing = function () /* listenables..., callback*/{
    _.throwIf(arguments.length &#x3c; 2, &#x22;Cannot create a join with less than 2 listenables!&#x22;);
    var listenables = slice.call(arguments),
        callback = listenables.pop(),
        numberOfListenables = listenables.length,
        join = {
        numberOfListenables: numberOfListenables,
        callback: this[callback] || callback,
        listener: this,
        strategy: strategy
    },
        i,
        cancels = [],
        subobj;
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        _.throwIf(this.validateListening(listenables[i]));
    }
    for (i = 0; i &#x3c; numberOfListenables; i++) {
        cancels.push(listenables[i].listen(newListener(i, join), this));
    }
    reset(join);
    subobj = { listenable: listenables };
    subobj.stop = makeStopper(subobj, cancels, this);
    this.subscriptions = (this.subscriptions || []).concat(subobj);
    return subobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Using the listener instance methods

All objects using the listener API (stores, React components using `ListenerMixin`, or other components using the `ListenerMethods
`) gain access to the four join instance methods, named after the argument strategy. Here&#x27;s an example saving the last emission
 from each publisher:

```javascript
var gainHeroBadgeStore = Reflux.createStore({
    init: function() {
        this.<span class="apidocCodeKeywordSpan">joinTrailing</span>(actions.disarmBomb, actions.saveHostage, actions.recoverData
, this.triggerAsync);
    }
});

actions.disarmBomb(&#x22;warehouse&#x22;);
actions.recoverData(&#x22;seedyletter&#x22;);
actions.disarmBomb(&#x22;docks&#x22;);
actions.saveHostage(&#x22;offices&#x22;,3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.listenTo" id="apidoc.element.reflux.ListenerMixin.listenTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenTo
        <span class="apidocSignatureSpan">(listenable, callback, defaultCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenTo(listenable, callback, defaultCallback) {
    var desub,
        unsubscriber,
        subscriptionobj,
        subs = this.subscriptions = this.subscriptions || [];
    _.throwIf(this.validateListening(listenable));
    this.fetchInitialState(listenable, defaultCallback);
    desub = listenable.listen(this[callback] || callback, this);
    unsubscriber = function unsubscriber() {
        var index = subs.indexOf(subscriptionobj);
        _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
        subs.splice(index, 1);
        desub();
    };
    subscriptionobj = {
        stop: unsubscriber,
        listenable: listenable
    };
    subs.push(subscriptionobj);
    return subscriptionobj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Creates a DataStore
var statusStore = Reflux.createStore({

    // Initial setup
    init: function() {

// Register statusUpdate action
this.<span class="apidocCodeKeywordSpan">listenTo</span>(statusUpdate, this.output);
    },

    // Callback
    output: function(flag) {
var status = flag ? &#x27;ONLINE&#x27; : &#x27;OFFLINE&#x27;;

// Pass on to listeners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.listenToMany" id="apidoc.element.reflux.ListenerMixin.listenToMany">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>listenToMany
        <span class="apidocSignatureSpan">(listenables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.callbackName(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + &#x22;Default&#x22;] || this[localname + &#x22;Default&#x22;] || localname);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
...you can do this:

```javascript
var actions = Reflux.createActions([&#x22;fireBall&#x22;,&#x22;magicMissile&#x22;]);

var Store = Reflux.createStore({
init: function() {
    this.<span class="apidocCodeKeywordSpan">listenToMany</span>(actions);
},
onFireBall: function(){
    // whoooosh!
},
onMagicMissile: function(){
    // bzzzzapp!
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.stopListeningTo" id="apidoc.element.reflux.ListenerMixin.stopListeningTo">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningTo
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningTo(listenable) {
    var sub,
        i = 0,
        subs = this.subscriptions || [];
    for (; i &#x3c; subs.length; i++) {
        sub = subs[i];
        if (sub.listenable === listenable) {
            sub.stop();
            _.throwIf(subs.indexOf(sub) !== -1, &#x22;Failed to remove listen from subscriptions list!&#x22;);
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.stopListeningToAll" id="apidoc.element.reflux.ListenerMixin.stopListeningToAll">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>stopListeningToAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopListeningToAll() {
    var remaining,
        subs = this.subscriptions || [];
    while (remaining = subs.length) {
        subs[0].stop();
        _.throwIf(subs.length !== remaining - 1, &#x22;Failed to remove listen from subscriptions list!&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.ListenerMixin.validateListening" id="apidoc.element.reflux.ListenerMixin.validateListening">
        function <span class="apidocSignatureSpan">reflux.ListenerMixin.</span>validateListening
        <span class="apidocSignatureSpan">(listenable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateListening(listenable) {
    if (listenable === this) {
        return &#x22;Listener is not able to listen to itself&#x22;;
    }
    if (!_.isFunction(listenable.listen)) {
        return listenable + &#x22; is missing a listen method&#x22;;
    }
    if (listenable.hasListener &#x26;&#x26; listenable.hasListener(this)) {
        return &#x22;Listener cannot listen to this listenable because of circular loop&#x22;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
var desub,
    unsubscriber,
    subscriptionobj,
    subs = this.subscriptions = this.subscriptions || [];
_.throwIf(this.<span class="apidocCodeKeywordSpan">validateListening</span>(listenable));
this.fetchInitialState(listenable, defaultCallback);
desub = listenable.listen(this[callback] || callback, this);
unsubscriber = function unsubscriber() {
    var index = subs.indexOf(subscriptionobj);
    _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
    subs.splice(index, 1);
    desub();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PublisherMethods" id="apidoc.module.reflux.PublisherMethods">module reflux.PublisherMethods</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.deferWith" id="apidoc.element.reflux.PublisherMethods.deferWith">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>deferWith
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deferWith(callback) {
    var oldTrigger = this.trigger,
        ctx = this,
        resolver = function resolver() {
        oldTrigger.apply(ctx, arguments);
    };
    this.trigger = function () {
        callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.listen" id="apidoc.element.reflux.PublisherMethods.listen">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>listen
        <span class="apidocSignatureSpan">(callback, bindContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listen(callback, bindContext) {
    bindContext = bindContext || this;
    var eventHandler = function eventHandler(args) {
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.addListener(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
// this creates &#x27;load&#x27;, &#x27;load.completed&#x27; and &#x27;load.failed&#x27;
var Actions = Reflux.createActions({
    &#x22;load&#x22;: {children: [&#x22;completed&#x22;,&#x22;failed&#x22;]}
});

// when &#x27;load&#x27; is triggered, call async operation and trigger related actions
Actions.load.<span class="apidocCodeKeywordSpan">listen</span>( function() {
    // By default, the listener is bound to the action
    // so we can access child actions using &#x27;this&#x27;
    someAsyncOperation()
        .then( this.completed )
        .catch( this.failed );
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.preEmit" id="apidoc.element.reflux.PublisherMethods.preEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>preEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preEmit() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.shouldEmit" id="apidoc.element.reflux.PublisherMethods.shouldEmit">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>shouldEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shouldEmit() {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.trigger" id="apidoc.element.reflux.PublisherMethods.trigger">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>trigger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.emit(this.eventLabel, args);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    },

    // Callback
    output: function(flag) {
        var status = flag ? &#x27;ONLINE&#x27; : &#x27;OFFLINE&#x27;;

        // Pass on to listeners
        this.<span class="apidocCodeKeywordSpan">trigger</span>(status);
    }

});
```

In the above example, whenever the action is called, the store&#x27;s `output` callback will be called with whatever parameters
were sent in the action. E.g. if the action is called as `statusUpdate(true)` then the flag argument in `output` function is `true
`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PublisherMethods.triggerAsync" id="apidoc.element.reflux.PublisherMethods.triggerAsync">
        function <span class="apidocSignatureSpan">reflux.PublisherMethods.</span>triggerAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function triggerAsync() {
    var args = arguments,
        me = this;
    _.nextTick(function () {
        me.trigger.apply(me, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var statusUpdate = Reflux.createAction(options);
```

An action is a [function object](http://en.wikipedia.org/wiki/Function_object) that can be invoked like any function.

```javascript
statusUpdate(data); // Invokes the action statusUpdate
statusUpdate.<span class="apidocCodeKeywordSpan">triggerAsync</span>(data); // same effect as above
```

If `options.sync` is true, the functor will instead call `action.trigger` which is a synchronous operation. You can change `action
.sync` during the lifetime of the action, and the following calls will honour that change.

There is also a convenience function for creating multiple actions.

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent" id="apidoc.module.reflux.PureComponent">module reflux.PureComponent</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.PureComponent" id="apidoc.element.reflux.PureComponent.PureComponent">
        function <span class="apidocSignatureSpan">reflux.</span>PureComponent
        <span class="apidocSignatureSpan">(props, context, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PureComponent = function (props, context, updater) {
		_extend.call(this, props, context, updater);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.extend" id="apidoc.element.reflux.PureComponent.extend">
        function <span class="apidocSignatureSpan">reflux.PureComponent.</span>extend
        <span class="apidocSignatureSpan">(clss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (clss) {
		return defineReact(null, null, clss);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Extending a 3rd Party Class

Sometimes 3rd party libraries will have their own class that extends `React.Component` that they require you to use. Reflux handles
 this by exposing the `Reflux.Component.extend` method. If you have such a 3rd party class you can pass that class to this method
 and it will return a version of `Reflux.Component` that extends it instead of extending `React.Component` directly. Example:

```javascript
import {ThirdPartyComponent} from &#x27;third-party&#x27;;

var RefluxThirdPartyComponent = Reflux.Component.<span class="apidocCodeKeywordSpan">extend</span>(ThirdPartyComponent);

class MyComponent extends RefluxThirdPartyComponent
{
    // ...
}
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.PureComponent.prototype" id="apidoc.module.reflux.PureComponent.prototype">module reflux.PureComponent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillMount" id="apidoc.element.reflux.PureComponent.prototype.componentWillMount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillMount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillMount = function () {
		// if there is a this.store then simply push it onto the this.stores array or make one if needed
		if (this.store) {
			if (Array.isArray(this.stores)) {
				this.stores.unshift(this.store);
			} else {
				this.stores = [this.store];
			}
		}
		
		if (this.stores) {
			this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
			var sS = this.setState.bind(this);
			// this handles the triggering of a store, checking what&#x27;s updated if proto.storeKeys is utilized
			var onStoreTrigger = function(obj){
				var updateObj = filterByStoreKeys(this.storeKeys, obj);
				if (updateObj) {
					sS(updateObj);
				}
			}.bind(this);
			// for each store in this.stores...
			for (var i = 0, ii = this.stores.length; i &#x3c; ii; i++) {
				var str = this.stores[i];
				// if&#x27;s a function then we know it&#x27;s a class getting passed, not an instance
				if (typeof str === &#x27;function&#x27;) {
					var storeId = str.id;
					// if there is NOT a .singleton property on the store then this store has not been initialized yet, so do so
					if (!str.singleton) {
						str.singleton = new str();
						if (storeId) {
							Reflux.stores[storeId] = str.singleton;
						}
					}
					// before we weren&#x27;t sure if we were working with an instance or class, so now we know an instance is created set it
					// to the variables we were using so that we can just continue on knowing it&#x27;s the instance we&#x27;re working with
					this.stores[i] = str = str.singleton;
					// the instance should have an .id property as well if the class does, so set that here
					str.id = storeId;
					// if there is an id and there is a global state property for this store then merge
					// the properties from that global state into the default state of the store AND then
					// set the global state to that new state (since it may have previously been partial)
					if (storeId &#x26;&#x26; Reflux.GlobalState[storeId]) {
						for (var key in Reflux.GlobalState[storeId]) {
							str.state[key] = Reflux.GlobalState[storeId][key];
						}
						Reflux.GlobalState[storeId] = str.state;
					// otherwise (if it has an id) set the global state to the default state of the store
					} else if (storeId) {
						Reflux.GlobalState[storeId] = str.state;
					}
					// if no id, then no messing with global state
				}
				// listen/subscribe for the &#x22;.trigger()&#x22; in the store, and track the unsubscribes so that we can unsubscribe on unmount
				if (!Reflux.serverMode) {
					this.__storeunsubscribes__.push(str.listen(onStoreTrigger));
				}
				// run set state so that it mixes in the props from the store with the component
				var updateObj = filterByStoreKeys(this.storeKeys, str.state);
				if (updateObj) {
					this.setState(updateObj);
				}
			}
		}
		
		// mapStoreToState needs to know if is ready to map or must wait
		this.__readytomap__ = true;
		// if there are mappings that were delayed, do them now
		var dmaps = this.__delayedmaps__;
		if (dmaps) {
			for (var j=0,jj=dmaps.length; j&#x3c;jj; j++) {
				dmaps[j].func( dmaps[j].state );
			}
		}
		this.__delayedmaps__ = null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
	// ...
	
	componentWillMount()
	{
		// ... your stuff ...
		
		super.<span class="apidocCodeKeywordSpan">componentWillMount</span>();
	}
	
	//...
```

### More:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.componentWillUnmount" id="apidoc.element.reflux.PureComponent.prototype.componentWillUnmount">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>componentWillUnmount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">componentWillUnmount = function () {
		if (this.__storeunsubscribes__) {
			for (var i = 0, ii = this.__storeunsubscribes__.length; i &#x3c; ii; i++) {
				this.__storeunsubscribes__[i]();
			}
		}
		this.__readytomap__ = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.PureComponent.prototype.mapStoreToState" id="apidoc.element.reflux.PureComponent.prototype.mapStoreToState">
        function <span class="apidocSignatureSpan">reflux.PureComponent.prototype.</span>mapStoreToState
        <span class="apidocSignatureSpan">(store, filterFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapStoreToState = function (store, filterFunc)
	{
		// make sure we have a proper singleton instance to work with
		if (typeof store === &#x27;function&#x27;) {
			if (store.singleton) {
				store = store.singleton;
			} else {
				store = Reflux.initStore(store);
			}
		}
		
		// we need a closure so that the called function can remember the proper filter function to use, so function gets defined here
		var self = this;
		function onMapStoreTrigger(obj) {
			// get an object
			var update = filterFunc.call(self, obj);
			// if no object returned from filter functions do nothing
			if (!update) {
				return;
			}
			// check if the update actually has any mapped props
			/*jshint unused: false */
			var hasProps = false;
			for (var check in update) {
				hasProps = true;
				break;
			}
			// if there were props mapped, then update via setState
			if (hasProps) {
				self.setState(update);
			}
		}
		
		// add the listener to know when the store is triggered
		this.__storeunsubscribes__ = this.__storeunsubscribes__ || [];
		this.__storeunsubscribes__.push(store.listen(onMapStoreTrigger));
		
		// now actually run onMapStoreTrigger with the full store state so that we immediately have all store state mapped to component
 state
		if (this.__readytomap__) {
			onMapStoreTrigger(store.state);
		} else {
			this.__delayedmaps__ = this.__delayedmaps__ || [];
			this.__delayedmaps__.push({func:onMapStoreTrigger, state:store.state});
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This method takes 2 arguments: the `Reflux.Store` you want mapped to the component state (either the class itself or the singleton
 instance) and a mapping function supplied by you. The mapping function will be called any time the store instance&#x27;s `setState
` is used to change the state of the store. The mapping function takes an argument which will be the state change object from the
 store for that particular change. It needs to return an object which will then be mapped to the component state (similar to if
that very returned object were used in the component&#x27;s `setState`). If an object with no properties is returned then the component
 will *not* re-render. The mapping function is also called with its `this` keyword representing the component, so comparing store
 values to current component state values via `this.state` is possible as well.

```javascript
class Counter extends Reflux.Component
{
constructor(props) {
    super(props);
    this.<span class="apidocCodeKeywordSpan">mapStoreToState</span>(MyStoreClass, function(fromStore){
        var obj = {};
        if (fromStore.color)
            obj.color = fromStore.color;
        if (fromStore.data &#x26;&#x26; fromStore.data.classToUse)
            obj.class = fromStore.data.classToUse;
        return obj;
    });
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Store" id="apidoc.module.reflux.Store">module reflux.Store</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.Store.Store" id="apidoc.element.reflux.Store.Store">
        function <span class="apidocSignatureSpan">reflux.</span>Store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store = function () {
		// extending doesn&#x27;t really work well here, so instead we create an internal instance
		// and just loop through its properties/methods and make a getter/setter for each
		// that will actually be getting and setting on that internal instance.
		this.__store__ = Reflux.createStore();
		this.state = {};
		var self = this;
		for (var key in this.__store__) {
			/*jshint loopfunc: true */
			(function (prop) {
				Object.defineProperty(self, prop, {
					get: function () { return self.__store__[prop]; },
					set: function (v) { self.__store__[prop] = v; }
				});
			})(key);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.Store.prototype" id="apidoc.module.reflux.Store.prototype">module reflux.Store.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.Store.prototype.setState" id="apidoc.element.reflux.Store.prototype.setState">
        function <span class="apidocSignatureSpan">reflux.Store.prototype.</span>setState
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setState = function (obj) {
		// Object.assign(this.state, obj); // later turn this to Object.assign and remove loop once support is good enough
		for (var key in obj) {
			this.state[key] = obj[key];
		}
		// if there&#x27;s an id (i.e. it&#x27;s being tracked by the global state) then make sure to update the global state
		if (this.id) {
			Reflux.GlobalState[this.id] = this.state;
		}
		// trigger, because any component it&#x27;s attached to is listening and will merge the store state into its own on a store trigger
		this.trigger(obj);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Register your component to listen for changes in your data stores, preferably in the `componentDidMount` [lifecycle method](http
://facebook.github.io/react/docs/component-specs.html) and unregister in the `componentWillUnmount`, like this:

```javascript
var Status = React.createClass({
getInitialState: function() { },
onStatusChange: function(status) {
    this.<span class="apidocCodeKeywordSpan">setState</span>({
        currentStatus: status
    });
},
componentDidMount: function() {
    this.unsubscribe = statusStore.listen(this.onStatusChange);
},
componentWillUnmount: function() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.__keep" id="apidoc.module.reflux.__keep">module reflux.__keep</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.__keep.addAction" id="apidoc.element.reflux.__keep.addAction">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addAction
        <span class="apidocSignatureSpan">(act)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addAction(act) {
	if (use) {
		createdActions.push(act);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var async = !functor.sync &#x26;&#x26; typeof functor.sync !== &#x22;undefined&#x22; || hasChildActions;
        var triggerType = async ? &#x22;triggerAsync&#x22; : &#x22;trigger&#x22;;
        return functor[triggerType].apply(functor, arguments);
    };

    _.extend(functor, childActions, context);

    Keep.<span class="apidocCodeKeywordSpan">addAction</span>(functor);

    return functor;
}
},{&#x22;./ActionMethods&#x22;:2,&#x22;./Keep&#x22;:3,&#x22;./PublisherMethods&#x22;:5,&#x22;./utils&#x22;:13}],9:[function(require
,module,exports){
&#x22;use strict&#x22;;

Object.defineProperty(exports, &#x22;__esModule&#x22;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.addStore" id="apidoc.element.reflux.__keep.addStore">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>addStore
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addStore(str) {
	if (use) {
		createdStores.push(str);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
        }
    }

    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

    var store = new Store();
    Keep.<span class="apidocCodeKeywordSpan">addStore</span>(store);

    return store;
}
},{&#x22;./Keep&#x22;:3,&#x22;./ListenerMethods&#x22;:4,&#x22;./PublisherMethods&#x22;:5,&#x22;./StoreMethods&#x22;:6,&#x22;./bindMethods
&#x22;:7,&#x22;./mixer&#x22;:12,&#x22;./utils&#x22;:13}],10:[function(require,module,exports){
&#x22;use strict&#x22;;

Object.defineProperty(exports, &#x22;__esModule&#x22;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.reset" id="apidoc.element.reflux.__keep.reset">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
	while (createdStores.length) {
		createdStores.pop();
	}
	while (createdActions.length) {
		createdActions.pop();
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.__keep.useKeep" id="apidoc.element.reflux.__keep.useKeep">
        function <span class="apidocSignatureSpan">reflux.__keep.</span>useKeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function useKeep() {
	var bool = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : true;

	use = bool;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils" id="apidoc.module.reflux.utils">module reflux.utils</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var chDef = definition.children[i];
    var chName = typeof chDef === &#x22;string&#x22; ? chDef : chDef.actionName;
    childActions[chName] = createAction(chDef);
}

var context = _.extend({
    eventLabel: &#x22;action&#x22;,
    emitter: new _.<span class="apidocCodeKeywordSpan">EventEmitter</span>(),
    _isAction: true
}, PublisherMethods, ActionMethods, definition);

var functor = function functor() {
    var hasChildActions = false;
    /* eslint no-unused-vars:0 */
    for (var ignore in functor.childActions) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.callbackName" id="apidoc.element.reflux.utils.callbackName">
        function <span class="apidocSignatureSpan">reflux.utils.</span>callbackName
        <span class="apidocSignatureSpan">(string, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function callbackName(string, prefix) {
    prefix = prefix || &#x22;on&#x22;;
    return prefix + exports.capitalize(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * A convenience method that listens to all listenables in the given object.
 *
 * @param {Object} listenables An object of listenables. Keys will be used as callback method names.
 */
var listenToMany = exports.listenToMany = function listenToMany(listenables) {
    var allListenables = flattenListenables(listenables);
    for (var key in allListenables) {
        var cbname = _.<span class="apidocCodeKeywordSpan">callbackName</span>(key),
            localname = this[cbname] ? cbname : this[key] ? key : undefined;
        if (localname) {
            this.listenTo(allListenables[key], localname, this[cbname + &#x22;Default&#x22;] || this[localname + &#x22;Default&#
x22;] || localname);
        }
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.capitalize" id="apidoc.element.reflux.utils.capitalize">
        function <span class="apidocSignatureSpan">reflux.utils.</span>capitalize
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // recursively flatten children
        var children = flattenListenables(childMap);

        // add the primary listenable and chilren
        flattened[key] = listenable;
        for (var childKey in children) {
            var childListenable = children[childKey];
            flattened[key + _.<span class="apidocCodeKeywordSpan">capitalize</span>(childKey)] = childListenable;
        }
    }

    return flattened;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.extend" id="apidoc.element.reflux.utils.extend">
        function <span class="apidocSignatureSpan">reflux.utils.</span>extend
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    var source, keys, prop;
    for (var i = 1, length = arguments.length; i &#x3c; length; i++) {
        source = arguments[i];
        keys = Object.keys(source);
        for (var j = 0; j &#x3c; keys.length; j++) {
            prop = keys[j];
            if (Object.getOwnPropertyDescriptor &#x26;&#x26; Object.defineProperty) {
                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
                Object.defineProperty(obj, prop, propertyDescriptor);
            } else {
                obj[prop] = source[prop];
            }
        }
    }
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Extending a 3rd Party Class

Sometimes 3rd party libraries will have their own class that extends `React.Component` that they require you to use. Reflux handles
 this by exposing the `Reflux.Component.extend` method. If you have such a 3rd party class you can pass that class to this method
 and it will return a version of `Reflux.Component` that extends it instead of extending `React.Component` directly. Example:

```javascript
import {ThirdPartyComponent} from &#x27;third-party&#x27;;

var RefluxThirdPartyComponent = Reflux.Component.<span class="apidocCodeKeywordSpan">extend</span>(ThirdPartyComponent);

class MyComponent extends RefluxThirdPartyComponent
{
    // ...
}
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.inherits" id="apidoc.element.reflux.utils.inherits">
        function <span class="apidocSignatureSpan">reflux.utils.</span>inherits
        <span class="apidocSignatureSpan">(subClass, superClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherits = function (subClass, superClass) {
	if (typeof superClass !== &#x22;function&#x22; &#x26;&#x26; superClass !== null) {
		throw new TypeError(&#x22;Super expression must either be null or a function, not &#x22; + typeof superClass);
	}
	subClass.prototype = Object.create(superClass &#x26;&#x26; superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass) {
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(subClass, superClass);
		} else {
			/* jshint proto: true */
			subClass.__proto__ = superClass;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* NOTE: New `MyStore.state` shortcut (from 6.4.0) is not available in IE10 and below, use accordingly in your projects.
* Remove test for it so that it doesn&#x27;t fail, and is undocumented feature for now, until the day we can drop IE9 and IE10.

## v6.4.0

* Improved on class extending function used internally.
* Made that extending function available externally at `Reflux.utils.<span class="apidocCodeKeywordSpan">inherits</span>(NewClass
, InheritsFrom)` so that it can be used for testing.
* Made `MyStore.state` work as shortcut access to `MyStore.singleton.state` (not available in IE9 and IE10, plan usage accordingly
 for your project).

## v6.3.0

* Added Reflux.PureComponent which extends from React.PureComponent instead of React.Component.

## v6.2.0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isArguments" id="apidoc.element.reflux.utils.isArguments">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isArguments
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArguments(value) {
    return (typeof value === &#x22;undefined&#x22; ? &#x22;undefined&#x22; : _typeof(value)) === &#x22;object&#x22; &#x26;&#x26; &#x22;callee&#x22; in value &#x26;&#x26; typeof value.length
 === &#x22;number&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Publishes an event using `this.emitter` (if `shouldEmit` agrees)
*/
var trigger = exports.trigger = function trigger() {
   var args = arguments,
       pre = this.preEmit.apply(this, args);
   args = pre === undefined ? args : _.<span class="apidocCodeKeywordSpan">isArguments</span>(pre) ? pre : [].concat(pre);
   if (this.shouldEmit.apply(this, args)) {
       this.emitter.emit(this.eventLabel, args);
   }
};

/**
* Tries to publish the event on the next tick
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isFunction" id="apidoc.element.reflux.utils.isFunction">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(value) {
    return typeof value === &#x22;function&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  listened to.
 * @returns {String|Undefined} An error message, or undefined if there was no problem.
 */
var validateListening = exports.validateListening = function validateListening(listenable) {
    if (listenable === this) {
        return &#x22;Listener is not able to listen to itself&#x22;;
    }
    if (!_.<span class="apidocCodeKeywordSpan">isFunction</span>(listenable.listen)) {
        return listenable + &#x22; is missing a listen method&#x22;;
    }
    if (listenable.hasListener &#x26;&#x26; listenable.hasListener(this)) {
        return &#x22;Listener cannot listen to this listenable because of circular loop&#x22;;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.isObject" id="apidoc.element.reflux.utils.isObject">
        function <span class="apidocSignatureSpan">reflux.utils.</span>isObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(obj) {
    var type = typeof obj === &#x22;undefined&#x22; ? &#x22;undefined&#x22; : _typeof(obj);
    return type === &#x22;function&#x22; || type === &#x22;object&#x22; &#x26;&#x26; !!obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * be overridden in the definition object.
 *
 * @param {Object} definition The action object definition
 */
function createAction(definition) {

definition = definition || {};
if (!_.<span class="apidocCodeKeywordSpan">isObject</span>(definition)) {
    definition = { actionName: definition };
}

for (var a in ActionMethods) {
    if (!allowed[a] &#x26;&#x26; PublisherMethods[a]) {
        throw new Error(&#x22;Cannot override API method &#x22; + a + &#x22; in Reflux.ActionMethods. Use another method name or
 override it on Reflux.PublisherMethods instead.&#x22;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.nextTick" id="apidoc.element.reflux.utils.nextTick">
        function <span class="apidocSignatureSpan">reflux.utils.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
    setTimeout(callback, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Whenever action functors are called, they return immediately through the use of `setTimeout` (`nextTick` function) internally.

You may switch out for your favorite `setTimeout`, `nextTick`, `setImmediate`, et al implementation:

```javascript

// node.js env
Reflux.<span class="apidocCodeKeywordSpan">nextTick</span>(process.nextTick);
```

For better alternative to `setTimeout`, you may opt to use the [`setImmediate` polyfill](https://github.com/YuzuJS/setImmediate), [`
setImmediate2`](https://github.com/Katochimoto/setImmediate) or [`macrotask`](https://github.com/calvinmetcalf/macrotask).


### Joining parallel listeners with composed listenables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.object" id="apidoc.element.reflux.utils.object">
        function <span class="apidocSignatureSpan">reflux.utils.</span>object
        <span class="apidocSignatureSpan">(keys, vals)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function object(keys, vals) {
    var o = {},
        i = 0;
    for (; i &#x3c; keys.length; i++) {
        o[keys[i]] = vals[i];
    }
    return o;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    return {
        getInitialState: function() {
if (!_.isFunction(listenable.getInitialState)) {
    return {};
}

return _.<span class="apidocCodeKeywordSpan">object</span>([key],[listenable.getInitialState()]);
        },
        componentDidMount: function() {
var me = this;

_.extend(me, ListenerMethods);

this.listenTo(listenable, function(v) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.throwIf" id="apidoc.element.reflux.utils.throwIf">
        function <span class="apidocSignatureSpan">reflux.utils.</span>throwIf
        <span class="apidocSignatureSpan">(val, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throwIf(val, msg) {
    if (val) {
        throw Error(msg || val);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
 */
var listenTo = exports.listenTo = function listenTo(listenable, callback, defaultCallback) {
var desub,
    unsubscriber,
    subscriptionobj,
    subs = this.subscriptions = this.subscriptions || [];
_.<span class="apidocCodeKeywordSpan">throwIf</span>(this.validateListening(listenable));
this.fetchInitialState(listenable, defaultCallback);
desub = listenable.listen(this[callback] || callback, this);
unsubscriber = function unsubscriber() {
    var index = subs.indexOf(subscriptionobj);
    _.throwIf(index === -1, &#x22;Tried to remove listen already gone from subscriptions list!&#x22;);
    subs.splice(index, 1);
    desub();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter" id="apidoc.module.reflux.utils.EventEmitter">module reflux.utils.EventEmitter</a></h1>




    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.EventEmitter" id="apidoc.element.reflux.utils.EventEmitter.EventEmitter">
        function <span class="apidocSignatureSpan">reflux.utils.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() { /* Nothing to set */ }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var chDef = definition.children[i];
    var chName = typeof chDef === &#x22;string&#x22; ? chDef : chDef.actionName;
    childActions[chName] = createAction(chDef);
}

var context = _.extend({
    eventLabel: &#x22;action&#x22;,
    emitter: new _.<span class="apidocCodeKeywordSpan">EventEmitter</span>(),
    _isAction: true
}, PublisherMethods, ActionMethods, definition);

var functor = function functor() {
    var hasChildActions = false;
    /* eslint no-unused-vars:0 */
    for (var ignore in functor.childActions) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.reflux.utils.EventEmitter.prototype" id="apidoc.module.reflux.utils.EventEmitter.prototype">module reflux.utils.EventEmitter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.addListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.addListener">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>addListener
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (aborted) {
            return;
        }
        callback.apply(bindContext, args);
    },
        me = this,
        aborted = false;
    this.emitter.<span class="apidocCodeKeywordSpan">addListener</span>(this.eventLabel, eventHandler);
    return function () {
        aborted = true;
        me.emitter.removeListener(me.eventLabel, eventHandler);
    };
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.emit" id="apidoc.element.reflux.utils.EventEmitter.prototype.emit">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>emit
        <span class="apidocSignatureSpan">(event, a1, a2, a3, a4, a5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (&#x27;function&#x27; === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i &#x3c; len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i &#x3c; length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j &#x3c; len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Publishes an event using `this.emitter` (if `shouldEmit` agrees)
 */
var trigger = exports.trigger = function trigger() {
    var args = arguments,
        pre = this.preEmit.apply(this, args);
    args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
    if (this.shouldEmit.apply(this, args)) {
        this.emitter.<span class="apidocCodeKeywordSpan">emit</span>(this.eventLabel, args);
    }
};

/**
 * Tries to publish the event on the next tick
 */
var triggerAsync = exports.triggerAsync = function triggerAsync() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.eventNames" id="apidoc.element.reflux.utils.EventEmitter.prototype.eventNames">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  var events = this._events
    , names = []
    , name;

  if (!events) return names;

  for (name in events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.listeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.listeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>listeners
        <span class="apidocSignatureSpan">(event, exists)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(event, exists) {
  var evt = prefix ? prefix + event : event
    , available = this._events &#x26;&#x26; this._events[evt];

  if (exists) return !!available;
  if (!available) return [];
  if (available.fn) return [available.fn];

  for (var i = 0, l = available.length, ee = new Array(l); i &#x3c; l; i++) {
    ee[i] = available[i].fn;
  }

  return ee;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.off" id="apidoc.element.reflux.utils.EventEmitter.prototype.off">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &#x26;&#x26; !listeners.once)
        || (context &#x26;&#x26; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &#x3c; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &#x26;&#x26; !listeners[i].once)
          || (context &#x26;&#x26; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.on" id="apidoc.element.reflux.utils.EventEmitter.prototype.on">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(event, fn, context) {
  var listener = new EE(fn, context || this)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.once" id="apidoc.element.reflux.utils.EventEmitter.prototype.once">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(event, fn, context) {
  var listener = new EE(fn, context || this, true)
    , evt = prefix ? prefix + event : event;

  if (!this._events) this._events = prefix ? {} : Object.create(null);
  if (!this._events[evt]) this._events[evt] = listener;
  else {
    if (!this._events[evt].fn) this._events[evt].push(listener);
    else this._events[evt] = [
      this._events[evt], listener
    ];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[prefix ? prefix + event : event];
  else this._events = prefix ? {} : Object.create(null);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.removeListener" id="apidoc.element.reflux.utils.EventEmitter.prototype.removeListener">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(event, fn, context, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events || !this._events[evt]) return this;

  var listeners = this._events[evt]
    , events = [];

  if (fn) {
    if (listeners.fn) {
      if (
           listeners.fn !== fn
        || (once &#x26;&#x26; !listeners.once)
        || (context &#x26;&#x26; listeners.context !== context)
      ) {
        events.push(listeners);
      }
    } else {
      for (var i = 0, length = listeners.length; i &#x3c; length; i++) {
        if (
             listeners[i].fn !== fn
          || (once &#x26;&#x26; !listeners[i].once)
          || (context &#x26;&#x26; listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[evt] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[evt];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var listeners = this._events[evt]
, len = arguments.length
, args
, i;

  if (&#x27;function&#x27; === typeof listeners.fn) {
if (listeners.once) this.<span class="apidocCodeKeywordSpan">removeListener</span>(event, listeners.fn, undefined, true);

switch (len) {
  case 1: return listeners.fn.call(listeners.context), true;
  case 2: return listeners.fn.call(listeners.context, a1), true;
  case 3: return listeners.fn.call(listeners.context, a1, a2), true;
  case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
  case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners" id="apidoc.element.reflux.utils.EventEmitter.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">reflux.utils.EventEmitter.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners() {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
